# 数组部分题目



## unordered_map的经典用法题目




### 1）两数之和

[两数之和](https://www.nowcoder.com/practice/20ef0972485e41019e39543e8e895b7f?tpId=191&&tqId=36133&rp=1&ru=/ta/job-code-high-algorithm&qru=/ta/job-code-high-algorithm/question-ranking)


#### 注意点：
1）unordered_map的find要是找不到返回的东西 mp.end()
2）map的键和值是唯一的，所以本题显然是不能用的。
3）multimap可以一个键对应多个值，unorder_map也是一样。
- 区别，mulimap不仅映射并且按key排序的需求
- unorder_map只映射，不按key(键)排序。

所以，我们才可以将比如 3 2 2 3 寻找6
将3映射为0，将3映射为3，这样来解题

```cpp

//奇怪的是，为什么这题中，我想要用unordered_map还用亲自弄头文件
//当然显然#include <unordered_map>也是可以的
#include<bits/stdc++.h>

class Solution {
public:
    /**
     * 
     * @param numbers int整型vector 
     * @param target int整型 
     * @return int整型vector
     */
    vector<int> twoSum(vector<int>& numbers, int target) {
        // write code here
        unordered_map<int,int> mp;
        
        int len=numbers.size();
        for( int i=0; i<len ; ++i )
        {
            mp[ numbers[i] ]=i;
        }
        
        for( int i=0; i<len ; ++i )
        {
            int num=target-numbers[i];
            
            //如果num存在！！！并且不是nums[i]本身
            if( mp.find(num)!= mp.end() && mp[num]!=i )
            {
                int a=i+1;
                int b=mp[num]+1;
                vector<int> rt;
                rt.push_back(a);
                rt.push_back(b);
                return rt;
            }
        }
        
        
    }
};
```







