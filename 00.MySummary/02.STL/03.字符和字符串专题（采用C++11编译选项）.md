# C++的OJ编程强化（字符和字符串）

目的，精简代码，强化数据结构和算法




##  前置说明




### 1）参考手册网址
用于查看声明，比VS系列编译器的简洁明了一些，还有示例程序
1）[cplusplus.com（我常用这个）](http://www.cplusplus.com/reference/)
网址：`http://www.cplusplus.com/reference/`

2）[zh.cppreference（看C++11常用）](https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5)
网址：`https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5`





### 2）字符和字符串在C语言和C++中的区别和联系

>- 字符：
C语言和`C++`中都是用char来承载，`C++`中string类，[]运算符返回的也是char
>- 字符串：
C语言中，用字符数组来承载
`C++`中用string类来承载
为了能够将`C++`中其他STL和string类的配合到极致，我们需要非常熟悉C语言风格的字符数组和`C++`的string类的互相转化。







## 一、精简代码



### 1）简化判别字母、数字


分类函数,所在函数库为`ctype.h`

**注意，虽然输入说是int，但是其实我们要放进去的是char（其实是对应的ASCII码值），这样才能判断。**

```cpp
int isalpha(int ch);
//alphabet n.字母表
//若ch是字母('A'-'Z','a'-'z')返回 非0值 ,否则返回0
//虽然我测试大写字母，返回是1，小写字母是2，但我还是不确定底层是不是这样规定的。

int isalnum(int ch);
//alphabet+number
//若ch是字母('A'-'Z','a'-'z')或数字('0'-'9') 返回非0值,否则返回0


int isdigit(int ch);
//digit n.数字
//若ch是数字('0'-'9')返回非0值,否则返回0


int islower(int ch)；
//若ch是小写字母('a'-'z')返回非0值,否则返回0


int isupper(int ch);
//若ch是大写字母('A'-'Z')返回非0值,否则返回0

int tolower(int ch);
//若ch是大写字母('A'-'Z')返回相应的小写字母('a'-'z')
//否则对应的ASCII码不变，直接返回原先的
//返回值是ASCII码，可以强制转换为char

int toupper(int ch);
//若ch是小写字母('a'-'z')返回相应的大写字母('A'-'Z')
//否则对应的ASCII码不变，直接返回原先的
//返回值是ASCII码，可以强制转换为char


int isxdigit(int ch);
//若ch是16进制数('0'-'9','A'-'F','a'-'f')返回非0值, 否则返回0


```



## 二、C++中string类细节源码阅读

<font style="background: yellow" size=3>Tips:字符串是逻辑概念，C语言中用字符数组来承载，C++中用string类来承载</font>

要想短时间强化这些，请暂停自己熟悉的字符数组，进行下面的强化。



### 1）[]运算符重载（用途：完成string类到char的转换）

#### （1-1）cplusplus.com（我常用这个）上的声明如下

<font style="background: yellow" size=5>重点：返回的是“字符”，不是什么string类</font>



```txt

const char& operator[] (size_t pos) const;

char& operator[] (size_t pos);

```





有C++教程上写的声明是，显然是参考的这，并且教程讲参考手册的改为这样，增加了可读性。

```txt

const char & operator[] (int n) const;

char & operator[] (int n);

const char & at(int n) const;

```



#### （1-2）zh.cppreference声明如下

```txt

// 元素访问

    constexpr const_reference operator[](size_type pos) const;

    constexpr reference       operator[](size_type pos);

    constexpr const_reference at(size_type n) const;

    constexpr reference       at(size_type n);

```





[知乎](https://www.zhihu.com/question/35614219/answer/798370856)上对于constexpr的解释

```txt

constexpr是`C++11`引入的，一方面是为了引入更多的编译时计算能力，另一方面也是解决 C++98 的 const 的双重语义问题。

在 C 里面，const 很明确只有「只读」一个语义，不会混淆。C++ 在此基础上增加了「常量」语义，也由 const 关键字来承担，引出来一些奇怪的问题。C++11 把「常量」语义拆出来，交给新引入的 constexpr 关键字。

在 C++11 以后，建议凡是「常量」语义的场景都使用 constexpr，只对「只读」语义使用 const。

```






### 2）成员函数c_str()（用途：完成string类到字符数组的转换）


连接string类和C语言字符数组的桥梁



<font style="background: yellow" size=3>重点：返回的是“const char*”，不是什么string类</font>

cplusplus.com上的声明如下

```txt
const char* c_str() const;	//返回一个以'\0'结尾的字符串的首地址
```





```txt
Get C string equivalent
Returns a pointer to an array that contains a null-terminated sequence of characters (i.e., a C-string) representing the current value of the string object.
This array includes the same sequence of characters that make up the value of the string object plus an additional terminating null-character ('\0') at the end.
翻译：该数组包括组成字符串对象值的相同字符序列，最后还有一个额外的终止空字符（'\ 0'）
```
<font style="background: red" size=3>从说明来看，我们使用这个进行string到字符数组的转换，我们就不要担心在字符数组后有没有加'\0'了，而如果用string类的成员函数copy()来进行转换，它却没有给我们在最后加'\0'，容易导致一些人误用</font>



#### 用法1

//主要要注意，这种const修饰，表示指向位置的内容不准修改。

```cpp

#include<iostream>

#include<string>

using namespace std;



int main()

{

	string str;

	str="abscv";

	//主要要注意，这种const修饰，表示指向位置的内容不准修改。

	const char * p=str.c_str(); 

	

	printf("%c\n",p[1]);

	printf("%c\n",p[2]);

	

	return 0;

}

```



#### 用法2（常用）

用这种复制的方式，就突破了，上一种方式无法修改的桎梏 



```cpp

#include<iostream>

#include<string>

#include<cstring>

using namespace std;



int main()

{

	string str;

	str="abscv";

	

	char p[10];

	//用这种复制的方式，就突破了，上一种方式无法修改的桎梏 

	strcpy(p,str.c_str());

	

	p[1]='K'; 

	printf("%c\n",p[1]);

	printf("%c\n",p[2]);

	

	return 0;

}

```





### 3）C语言字符数组和字符到string类

<font style="background: yellow" size=3>C语言字符数组和字符到string类都很简单，因为都实现了运算符+=和=的重载</font>

#### +=重载（字符用）
```cpp
#include<iostream>
using namespace std;

int main()
{
	char c='9';
	string str="432";
	str+=c;//原型是string& operator+= (char c);
	cout<<str; 
	return 0;
 } 
```


#### =重载（字符用）

```cpp
#include<iostream>
using namespace std;

int main()
{
	char c='9';
	string str="432";
	str=c;//原型是string& operator= (char c);
	cout<<str; 
	return 0;
}
//输出9
```


#### +=重载（字符串用）

```cpp
#include<iostream>
using namespace std;

int main()
{
	char test[]="356425462";
	string str;
	str+=test;//原型string & operator+=(const char * s);
	cout<<str; 
	return 0;
} 
```

#### =重载（字符串用）
```cpp
#include<iostream>
using namespace std;

int main()
{
	char test[]="11111";
	string str="432";
	str=test;//原型为 string& operator= (const char* s);
	cout<<str; 
	return 0;
} 
//输出11111
```






### 3）强化string类的成员函数（熟练到，心到码到）

string类和map等容器的配合，后续会知道好处的。


find查找
substr子串

深信服的笔试似乎蛮喜欢考字符串的。
CCF/CSP好像蛮喜欢那些字符串。









## 4）C++11支持的正则表达式（对付CSP第3题）

正则的编译时比较慢的，我们暂时
字符编码，我们的控制台的字符编码是GBK的，所以，要是能够改为UTF-8就不会乱码

<font size=5 style="background: yellow">注意记得开启C++11编译选项和`#include <regex>`</font>

[链接:看regex头文件定义的传送门](https://zh.cppreference.com/w/cpp/regex)

注意`C++11`新增了正则表达式的标准库支持
在 `C++` 中使用正则表达式，和其它语言差别不大
`C++11` 自带了 6 种正则表达式语法的支持
```txt
ECMAScript
basic
extended
awk
grep
egrep
C++11 默认使用 ECMAScript 语法，这也是 6 种语法中最强大的，假如想使用其他 5 种语法，只需在声明 regex 对象时指定即可
```





C++正则表达式最常用的三个函数为，也是一般用法。
正则表达式算是字符串匹配中的一个微型元。







### 正则表达式
```txt
.表示任意匹配单个字符
*表示匹配0-n个前面那个字符串
+是1-n次
[a-z]区间，a-z
\d{3}表示匹配3个数字，固定是3个
```

### 1）regex_match（正则匹配）
尝试匹配一个正则表达式到整个字符序列(函数模板)


```cpp
#include<iostream>
#include<string>
#include<regex>
using namespace std;

int main()
{
	//正则表达式，也就是匹配规则	 
	//R的意思是取消转义，这样我们就能在里面不用转义了。否则下面的\d要改为\\d 
	regex test(R"(\d*)");
	
	string str="43141324";//现在全是数字，能够匹配上，输出是OK
    
    bool t;
    t=regex_match(str,test);
    //前面是要匹配的，后面是正则表达式（匹配规则）
    //但是如果是"123okom231"这样，用前面的正则表达式，那么结果是No
	
	if(t)
	{
		cout<<"OK"<<endl;
	} 
	else
	{
		cout<<"No"<<endl;
	}
    
    return 0; 
}
```

```cpp
#include<iostream>
#include<string>
#include<regex>
using namespace std;

int main()
{
	//正则表达式，也就是匹配规则	 
	//R的意思是取消转义，这样我们就能在里面不用转义了。否则下面的\d要改为\\d 
	regex test(R"(\d+[a-z]{2}\d+)");
	
	string str="4314er1324";
    
    bool t;
    t=regex_match(str,test);//前面是要匹配的，后面是正则表达式（匹配规则）
	
	if(t)
	{
		cout<<"OK"<<endl;
	} 
	else
	{
		cout<<"No"<<endl;
	}
    
    return 0; 
}
```


### 2）regex_search（正则搜索）





### 3）regex_replace（正则替换）

























