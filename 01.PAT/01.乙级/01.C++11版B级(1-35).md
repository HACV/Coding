# 乙级——共95题

# 1-35题



## B1001 害死人不偿命的(3n+1)猜想

一、思路和难点

- 无坑
- 简单模拟题目

二、代码

```cpp
#include<cstdio>
int main()
{
	int n;
	scanf("%d",&n);
	int sum;
	for(int i=0;;i++)
	{
		if(n==1)
		{
			sum=i;
			break;
		}
		else if(n%2==0)
		{
			n=n/2;
		}
		else
		{
			n=(3*n+1)/2;
		}
	}
	printf("%d",sum);
	
	return 0;
 } 
```

## B1002 写出这个数

 (20分)

一、思路和难点

二、代码

```cpp
#include<cstdio>
#include<iostream>
#include<string>
#include<cmath>
using namespace std;
void is(int n)
{
	if(n==0)
	cout<<"ling";
	else if(n==1)
	cout<<"yi";
	else if(n==2)
	cout<<"er";
	else if(n==3)
	cout<<"san";
	else if(n==4)
	cout<<"si";
	else if(n==5)
	cout<<"wu";
	else if(n==6)
	cout<<"liu";
	else if(n==7)
	cout<<"qi";
	else if(n==8)
	cout<<"ba";
	else if(n==9)
	cout<<"jiu";
}

int main()
{
	string str;
	cin>>str;
	int sum=0;
	for(int i=0;i<str.size();i++ )
	{
		sum+=(str[i]-'0');
	}
	
	int test;
	int k=0;
	while(1)
	{
		test=pow(10,k);
		if(sum/test==0)
		break;
		else
		k++;
	}
	
	int aa[k];
	
	for(int i=(k-1);i!=-1;i--)
	{
		aa[i]=sum%10;
		sum=sum/10;
	}
	
	for(int i=0;i<k;i++)
	{
		if(i!=(k-1)) 
		{
			is(aa[i]);	
			cout<<" ";	
		}
		else
			is(aa[i]);	
	}
	
	return 0;
}
//我也不知道为啥是对的，因为在0的时候，没有测试通过
```



## 1003 我要通过（ing）

**一、思路和难点**

- 我要通过（题目真心难懂）

**（1）吐槽**

题目真的出的是神马鬼，题意半天我没看懂。。。。

起初当真是没有理解到题目的意图，最基本的想法是按照三部分条件一步一步筛选即可，但是看到第三条就有些蒙圈了。难道是编译原理，自动机？我不禁拿出纸笔画开了图，自动机，自动机。。。妈蛋，这不扯淡呢么，这思路绝不靠谱！OK，于是，回过头来仔细思考，好好打量下这个题目。咦，似乎有一点不同。

**（2）学习**

出题目的人，出完题目之后，最好找人复审一下。不然，学计算机的人，，，，出的题目，似乎有时候真的说的不像是让人能立马听懂，甚至歧义。。。。。。

二、代码

### （1）部分正确的

```cpp
//部分正确？？


#include<iostream>
#include<string>
#include<cstdio>
#include<algorithm>
using namespace std;
void is(int n)
{
	if(n==1)
	cout<<"YES";
	else
	cout<<"NO";
}
int main()
{
	int n;
	scanf("%d",&n);
	string str;
	int aa[n][3];
	
	fill(aa[0],aa[0]+n*3,0);
	
	int out[n]={0};
	for(int i=0;i<n;i++)
	{
		cin>>str;
		
		for(int j=0;j<str.size() ;j++)
		{
			if(str[j]=='P')
			aa[i][0]++;
			else if(str[j]=='A')
			aa[i][1]++;
			else if(str[j]=='T')
			aa[i][2]++;
			else
			aa[i][0]=-100;
		}
		str.clear() ;
	}
	
	for(int i=0;i<n;i++)
	{
		if((aa[i][0]>0)&&(aa[i][1]>0)&&(aa[i][2]>0))
		out[i]=1;
		else
		out[i]=0;
	}
	
	for(int i=0;i<n;i++)
	{
		if(i!=(n-1))
		{
			is(out[i]);
			cout<<endl;
		}
		else
			is(out[i]);
	}
	
	
	return 0;
 } 
```







## B1004	成绩排名



```cpp
//主要在于struct的构造函数怎么写
#include<iostream>
#include<algorithm>
#include<string>
#include<cstdio>
#include<vector>
using namespace std;

struct node{
	string str1;
	string str2;
	int v;
	node(string ss,string s2,int k):  str1(ss),str2(s2),v(k) {}
};

int main()
{
	int n;
	scanf("%d",&n);
	vector<node> vi;
	int aa[n];
	string str1,str2;
	int c;
	for(int i=0;i<n;i++)
	{
		cin>>str1;
		cin>>str2;
		cin>>c;
		vi.push_back(node(str1,str2,c)); 
		aa[i]=c;
	}
	
	sort(aa,aa+n);
	int max,min;
	max=aa[n-1];
	min=aa[0];
	
	for(int j=0;;j++)
	{
		if(max==vi[j].v)
		{
			cout<<vi[j].str1<<" "<<vi[j].str2<<endl;
			break;
		}
	}
	
	for(int j=0;;j++)
	{
		if(min==vi[j].v)
		{
			cout<<vi[j].str1<<" "<<vi[j].str2;
			break;
		}
	}
	
	
	
	return 0;
}
```





## 1005	继续(3n+1)猜想（ing）



## B1006	换个格式输出整数



```cpp
#include<iostream>
#include<cstdio>

using namespace std;

int main()
{
	int n;
	scanf("%d",&n);
	int a=0,b=0,c=0;
	a=n/100;
	n=n-a*100;
	if(a!=0)
	{
		for(int i=0;i<a;i++)
		{
			printf("B");
		}
	}
	
	b=n/10;
	n=n-b*10;
	if(b!=0)
	{
		for(int i=0;i<b;i++)
		{
			printf("S");
		}
	}
	
	for(int i=1;i<=n;i++)
	{
		printf("%d",i);
	}
	
	return 0;
}
```





## 1007	素数对猜想（ing）



## B1008	数组元素循环右移问题

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;


int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	
	int aa[n];
	for(int i=0;i<n;i++)
	{
		scanf("%d",&aa[i]);
	}
	
	int s=0;
	//m为偏移量 ,j是用来保障所有数字都被遍历的,s是原始指针 
	for(int j=0;j<n-1;j++,s++)
	{
		printf("%d ",aa[(s-m+100*n)%n]) ;
	}
	
	printf("%d",aa[(s-m+100*n)%n]) ;
//	printf("ss"); 
	return 0;	
}
```





## B1009	说反话

```cpp
#include<cstdio>

char solution[50][20];

int main()
{

	char c;
	int i=0;
	
	while(~scanf("%s",solution[i]))
	{
		c=getchar();
		if(c=='\n')
		{
			break;
		}
		
		++i;
	}
	
	for(int j=i;j>=0;j--)
	{
		if(j!=0)
		{
			printf("%s ",solution[j]);
		}
		else
		{
			printf("%s",solution[j]);
		}
		
	}
	
	return 0;
}
```





## B1010	一元多项式求导

```cpp
#include<cstdio>
#include<cstring>

int test[2000+5];


int main()
{
	memset(test,-1,sizeof(test));
	
	int a,b;
	int i=0;
	
	while(~scanf("%d%d",&a,&b))
	{
		++i;//表示有i组 
		test[1+(2*(i-1))]=a;
		test[2*i]=b;
		
	}
	
	if(test[2*i]==0)
	{
		i--;
	}
	
	if(i)
	{
		for(int j=1;j<=i;j++)
	{
		printf("%d %d",test[1+(2*(j-1))]*test[2*j],test[2*j]-1);
		
		if(j!=i)
		printf(" ");
	}
	}
	else
	printf("0 0");//这个题目的陷阱所在
	
	return 0;
 } 
```







## B1011  [A+B 和 C](https://pintia.cn/problem-sets/994805260223102976/problems/994805312417021952) 

**一、思路和难点**

简单；

坑点：int+int可能会溢出int，我用的long long 解决



```cpp
#include<iostream>
#include<cstdio>
using namespace std;

int main(){
	
	int n;
	scanf("%d",&n);
	int test[n][4];
	
	long long aa;
	
	for(int i=0;i<n;i++)
	{
		
		scanf("%d%d%d",&test[i][0],&test[i][1],&test[i][2]);
		aa=(long long )test[i][0]+(long long)test[i][1];
		aa=aa-(long long)test[i][2];
		if(aa>0)
		test[i][3]=1;
	}
	
	for(int i=0;i<n-1;i++)
	{
		if(test[i][3]==1)
		{
			printf("Case #%d: true\n",i+1);
		}
		else
		printf("Case #%d: false\n",i+1);
	}
	
	if(test[n-1][3]==1)
	{
		printf("Case #%d: true",n);
	}
	else
		printf("Case #%d: false",n);
	
	return 0;
}
```







## B1012	数字分类

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<cmath>
using namespace std;

vector<int> one,two,four;
int five=-1;
int three=0;

int main()
{

	int n;
	scanf("%d",&n);

	int test;
	for(int i=0;i<n;i++)
	{
		scanf("%d",&test);
		
		if(test%5==0)
		one.push_back(test);
		else if(test%5==1)
		two.push_back(test);
		else if(test%5==2)
		three++;
		else if(test%5==3)
		four.push_back(test);
		else 
		{
			if(test>five)
			five=test;
		}		
	}
	
	int a=one.size();
	int sum=0;
	if(a)
	{
		for(int i=0;i<a;i++)
		{
			if(one[i]%2==0)
			sum+=one[i];
		}
		
		if(sum==0)
			printf("N ");	
		else	
			printf("%d ",sum);
	}
	else
	printf("N ");
	
	
	a=two.size();
	sum=0;
	if(a)
	{
		for(int i=0;i<a;i++)
		{
			sum+=(two[i]*pow(-1,i));
		}
		printf("%d ",sum);
	}
	else
	printf("N ");
	
	
	if(three)
	{
		printf("%d ",three);
	}
	else
	printf("N ");
	
	
	a=four.size();
	sum=0; 
	
	if(a)
	{
		double p;
		for(int i=0;i<a;i++)
		{
			sum+=four[i];
		} 
		p=(double)sum/(double)a;
		printf("%.1f ",p);
		
	 } 
	 else
	printf("N ");	 
	 
	
	if(five>0)
	{
		printf("%d",five);
	}
	else
	printf("N");	 
	 
	 
	 
	
	return 0;
 } 
```



## 1013	数素数（ing）



## B1014	福尔摩斯的约会

```cpp
#include<cstdio>

char Day[7][4]={"MON" ,"TUE","WED" ,"THU" ,"FRI" ,"SAT" ,"SUN" } ;
char one[65];
char two[65];
char three[65];
char four[65];

int is(char c)
{
	if(((c-'A')>=0)&&((c-'A')<=6))
	{
		
			return c-'A';//返回星期几0-6 
		
	}
	
	return -1; 
}


int test(char c)
{
	if(((c-'0')>=0)&&((c-'0')<=9))
	{
		return c-'0';
	}
	
	if((c-'A')>=0)
	{
		if((c-'A')<=13)
		{
			return c-'A'+10;
		}
		
	}
	
	
	return -1;
}

int Draw(char c)
{
	if((c-'a')>=0&&(c-'a')<=26)
	{
		return 1;
	}
	if((c-'A')>=0&&(c-'A')<=26)
	{
		return 1;
	}
	
	return 0;
}

int main()
{
	scanf("%s%s%s%s",one,two,three,four);

	int num_one=0;
	int num_two=0;
	
	int temp=0;
	
	for(int i=0;i<60;i++)
	{
//		printf("#####%d\n",is(one[i]));
		if(is(one[i])>-1)
		{
			
			if(is(two[i])==is(one[i]))
			{
				temp=i;
				num_one=is(two[i]);//获得星期几 ，输出Day[num_one] 
				break;
			}
		}
		
	}
	
	
	for(int i=temp+1;i<60;i++)
	{
		if(test(one[i])>-1)
		{
			if(test(two[i])==test(one[i]))
			{
				num_two=test(two[i]);//获得几点，输出num_two 2个格子 
//				printf("%c^^^^^^\n",two[i]);
				break;
			}
		}
	}
	
	int num_three=0;
	
	for(int i=0;i<60;i++)
	{
		if(three[i]==four[i])
		{
			if(Draw(three[i]))
			{
				num_three=i;
				
				break;
			}
			
		}
	}
	
	printf("%s %02d:%02d",Day[num_one],num_two,num_three);
	
	
	return 0;
}
```





## 1015	德才论（ing）




## B1016	部分A+B

**一、思路和难点**

坑点：注意范围

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;

int main(){
	
	long long a,b;
	int one ,two;
	scanf("%lld%d%lld%d",&a,&one,&b,&two);
//schar testone[10+5],testtwo[10+5];
	int s=a%10;	
	int sumone=0;
	while(a/=10)
	{
		if(s==one)
		{
			sumone++;
		}
		s=a%10;
	}
	if(s==one)
	sumone++;
	
	int ss=b%10;	
	int sumtwo=0;
	while(b/=10)
	{
		if(ss==two)
		{
			sumtwo++;
		}
		ss=b%10;
	}
	
	if(ss==two)
	sumtwo++;
	
	long long int Tone=0,Ttwo=0;
	for(int i=0;i<sumone;i++)
	{
		Tone+=(long long )one*pow(10,i);
	}
	
	for(int i=0;i<sumtwo;i++)
	{
		Ttwo+=(long long )two*pow(10,i);
	}
//		cout<<Tone<<endl;
//		cout<<Ttwo<<endl;
	long long cc=(long long)Tone+(long long)Ttwo;
	printf("%lld",cc);

		

	return 0;
}
```



## 1017	A除以B（ing）



## B1018	锤子剪刀布

格式好题。

注意格式：getchar的使用

由于scanf使用%c时会将换行符\n读入，因此需要在合适的地方用getchar吸收空格，否则会导致读入与题意不太符合——程序输入数据后闪退，基本上就是这个问题导致的。



````cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<cmath>
using namespace std;

int test(char aa,char bb)
{
	//0表示平手
	//-1表  甲win 
	if(aa=='B'&&bb=='B')
	return 0;
	else if(aa=='C'&&bb=='C')
	return 0;
	else if(aa=='J'&&bb=='J') 
	return 0;
	else if(aa=='B'&&bb=='C')
	return -1;
	else if(aa=='B'&&bb=='J')
	return 1;
	else if(aa=='C'&&bb=='J')
	return -1;
	else if(aa=='C'&&bb=='B')
	return 1;
	else if(aa=='J'&&bb=='B')
	return -1;
	else//JheC 
	return 1;
	
	
	
}

int main()
{

	int n;
	scanf("%d",&n);

	int a[3]={0};//0胜，1平，2负
	int b[3]={0};
	
	int a_one[3]={0};//0表示B布，1表示C锤子，2表示剪刀
	int b_two[3]={0};
	
	char aa,bb; 
	getchar();//易错 
	for(int i=0;i<n;i++)
	{
		scanf("%c %c",&aa,&bb);
		
		getchar();
		
//		printf("%c %c",aa,bb);
		if(test(aa,bb)==0)
		{
			a[1]++;
			b[1]++;
		}
		else if(test(aa,bb)==-1)
		{
			a[0]++;
			b[2]++;
			if(aa=='B')
			a_one[0]++;
			else if(aa=='C')
			a_one[1]++;
			else 
			a_one[2]++;
		}
		else 
		{
			b[0]++;
			a[2]++;
			if(bb=='B')
			b_two[0]++;
			else if(bb=='C')
			b_two[1]++;
			else 
			b_two[2]++;
		}
		
	}
	
	printf("%d %d %d\n",a[0],a[1],a[2]);
	printf("%d %d %d\n",b[0],b[1],b[2]);
	
	int out=a_one[0];
	
	int j=0;
	for(int i=1;i<3;i++)
	{
		if(a_one[i]>out)
		{
			j=i;
			out=a_one[i];
		}
	}
	
	if(j==0)
	printf("B ");
	else if(j==1)
	printf("C ");
	else
	printf("J ");
	
	
	
	out=b_two[0];
	
	j=0;
	for(int i=1;i<3;i++)
	{
		if(b_two[i]>out)
		{
			j=i;
			out=b_two[i];
		}
	}
	
	if(j==0)
	printf("B");
	else if(j==1)
	printf("C");
	else
	printf("J");
	

	
	return 0;
 } 
````



## 1019	数字黑洞（ing）



## 1020	月饼（ing）




## B1021	个位数统计

```cpp
#include<cstdio>
#include<cstring>
int solution[10]={0};


int main()
{
	char temp[1000+5];
	scanf("%s",temp);
	int num=strlen(temp);
	
	for(int i=0;i<num;i++)
	{
		solution[temp[i]-'0']++;
	}
	
	int sum=0;
	
	for(int i=0;i<10;i++)
	{
		if(solution[i])
		{
			sum+=solution[i];
			if(sum<num)
			{
				printf("%d:%d\n",i,solution[i]);
			
			}
			else 
			{
				printf("%d:%d",i,solution[i]);
			}
			
		}
		
		
		
	}
	
	return 0;
}
```





## B1022 D进制的A+B (20分)

- 方案和《算法笔记》差不多

```cpp
#include<bits/stdc++.h>
using namespace std;

int a,b,n,len;
int demo[32];
void solve()
{
	int num=a+b;
	len=0;
	while( 0!=(num/n) )
	{
		demo[len++]=num%n;
		num/=n;
	}
	
	demo[len]=num%n;
}

int main()
{
	while( ~scanf("%d%d%d",&a,&b,&n) )
	{
		solve();
		while( len>=0 )
		{
			printf("%d",demo[len--]);
		}
		printf("\n");
	}
	
	return 0;
}
```





## 1023	组个最小数（ing）



## B1024	科学计数法

```cpp
#include<cstdio>

char test[10000+5]={0};

int ppow(int a,int b)
{
	int temp=a;
	a=1;
	while(b--)
	{
		a*=temp;
	}
	return a;
}


int main()
{
	scanf("%s",test);
	int E_location=0;
	
	if(test[0]=='-')
	{
		printf("-");
	}
	
	for(int i=0;i<10000+5;i++)
	{
		if(test[i]=='E')
		{
			E_location=i;
			break;
		}
	} 
	
	int num=0;//表示左边移动或者右边移动的数目 
//	num=(test[E_location+2]-'0')*10+(test[E_location+3]-'0');
	
	int right=E_location+2;
	while(right++)
	{
		if(test[right]=='\0')
		{
			break;
		}
		
	}
//	printf("&&&&&\n");

	int k=0;
	for(int j=right-1;j>=E_location+2;j--)
	{
//		printf("%d&&&&&\n",ppow(10,k));
		num=num+(test[j]-'0')*ppow(10,k);
		k++;
	}
	
	
	//右移的 
	int tt=0,you;//不用补0 
	if(test[E_location+1]=='+')
	{
		if(E_location-3>=num)//不用换右边补0 
		{
			tt=0;
			you=num;
		} 
		else
		{
			tt=1;
			you=E_location-3;
			num-=you;//num变成看右边要补0个数 
		}
		
		for(int i=2;i<2+you;i++)
		{
				char temp=test[i+1];
				test[i+1]=test[i];
				test[i]=temp;
		}
		
		if(tt)
		{
			for(int i=1;i<E_location-1;i++)
			{
				printf("%c",test[i]);
			}
			for(int i=0;i<num;i++)
			{
				printf("0");
			}
		}
		else
		{
			for(int i=1;i<E_location-1;i++)
			{
				printf("%c",test[i]);
			}
			if(test[E_location-1]=='.')
			{
			}
			else
			{
				printf("%c",test[E_location-1]);
			}
		}
			
	} 
	
	
	//左移的 
	char t_temp;
	if(test[E_location+1]=='-')
	{
		if(0==num)
		{
			for(int i=1;i<=E_location-1;i++)
			{
				printf("%c",test[i]);
			}
		}
		
		if(num>=1)
		{
			t_temp=test[1];
			test[1]=test[2];
			test[2]=t_temp;
			
			printf("0.");
			--num;
			while(num--)
			{
				printf("0");
			}
			
			for(int i=2;i<=E_location-1;i++)
			{
				printf("%c",test[i]);
			}
			
		}
		
	} 
	
	
	return  0;
 } 
```





## 1025	反转链表（ing）



## B1026	程序运行时间

坑点：注意，输出格式

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;


int main()
{
	int a,b;
	scanf("%d%d",&a,&b);
	
	int sum=(int)round((double)(b-a)/100);
		
	int s=sum%3600; 
	
	int one=(sum/=3600);//小时 
	
	int three=s%60;//秒钟 
	
	int two=(s/60);//fen
	
	if(one>=10)
	{
		printf("%d:",one);
	}
	else
	{
		printf("0%d:",one);
	}
	
	if(two>=10)
	{
		printf("%d:",two);
	}
	else
	{
		printf("0%d:",two);
	}
	
	if(three>=10)
	{
		printf("%d",three);
	}
	else
	{
		printf("0%d",three);
	}
		
	return 0;	
}

	
```



餐考代码

1）四舍五入可以用math.h中的round函数，但是由于涉及浮点数会使写法变得复杂，因此不妨直接通过判断c2-c1的后2位来判断是四舍还是勿入，以避免浮点数运算

2）时分秒的输出要保证不足2位时高位补0，

```cpp
#include<bits/stdc++.h>
using namespace std;


int main()
{
	
	int c1,c2;
	scanf("%d%d",&c1,&c2);

	int ans=c2-c1;

	if( ans %100 >=50)
	{
		ans=ans/100+1;
	}
	else
	{
		ans=ans/100;
	}

	printf("%02d:%02d:%02d\n",ans/3600,ans%3600/60,ans%60);
	
	return 0;
 } 

```









## B1027 打印沙漏20 

```cpp



## 二、代码

求多少行，通项公式
Sn和


考点：模拟
坑点：n=1只输出一个符号的时候的边界，要注意

PAT和牛客都AC

​```cpp
#include<bits/stdc++.h>
using namespace std;



int solution(int n)
{
	int num=25;
	
	for(;num>0;--num)
	{
		if(2*num*num<=n)
		{
			break;
		}
	}
	
	return num;
}

void test(int num,char c)
{
	//uploop
	int up_loop=num;
	int up_num=2*num-1;
	
	//down loop
	int down_loop=num-1;
	int down_num=3;
	
	//前面空格的个数 
	int count=0;
	for( ;up_loop>0 ;  )
	{
		for(int i=0;i<count;++i)
		{
			printf(" ");
		}
		
		
		
		for(int i=0;i<up_num;++i)
		{
			printf("%c",c);
		}
		printf("\n");
		
		//下次空格 
		++count;
		//下次符号 
		up_num-=2;
		//还剩下的循环 
		--up_loop; 
	}
	
	count-=2;
	
	for( ;down_loop>0 ;  )
	{
		for(int i=0;i<count;++i)
		{
			printf(" ");
		}
		
		
		
		for(int i=0;i<down_num;++i)
		{
			printf("%c",c);
		}
		printf("\n");
		
		//下次空格 
		--count;
		//下次符号 
		down_num+=2;
		//还剩下的循环 
		--down_loop; 
	}
	
}


int main()
{
	int n;
	char c;
	while(~scanf("%d %c",&n,&c))
	{
		int num=solution(n);
		if(0!=num) 
		{
			test(num,c);
			printf("%d\n",n-(2*num*num-1));
		}
		else
		{
			//表示n=1
			printf("%c\n",c); 
			printf("0\n");
		}
		
		
	}
	
	return 0;
}
```



## B1028人口普查



二、代码



牛客上AC了，但是PAT上显示部分正确（格式错误）

其实牛客上忽略了一个东西。那就是合理的生日数目要是是0，那么就没有人名输出（坑点）
```cpp
#include<bits/stdc++.h>
using namespace std;

struct person
{
	char name[6];
	int year;
	int month;
	int day;
}maxman,minman,temp;


void init_struct()
{
	strcpy(maxman.name,temp.name);
	maxman.year=temp.year;
	maxman.month=temp.month;
	maxman.day=temp.day;
	
	strcpy(minman.name,temp.name);
	minman.year=temp.year;
	minman.month=temp.month;
	minman.day=temp.day;
}

//好在在草稿纸上分了情况。。。 
//本来以为还要考虑，闰年啥的，但是似乎，题目说的多少岁，只是简单的年限 
int test(struct person aa)
{
	//是否合法，合法1
	if((aa.year>1814)&&(aa.year<2014)) 
	{
		return 1;
	}
	else if(aa.year==1814)
	{
		if(aa.month>9) 
		{
			return 1;
		}
		else if(9==aa.month)
		{
			if(aa.day>=6)
			{
				return 1;
			}
			else
			{
				return 0;
			}
		}
		else
		{
			return 0;
		}
	}
	else if(aa.year==2014)
	{
		if(aa.month<9)
		{
			return 1;
		}
		else if(aa.month==9)
		{
			if(aa.day<=6)
			{
				return 1;
			}
			else
			{
				return 0;
			}
		}
		else
		{
			return 0; 
		} 
	}
	else
	{
		return 0;
	}
	
	
}


int struct_cmp(struct person a,struct person b)
{
	//比较两个合法，合理的年龄 
	//a比b年长则1，年轻则-1，相同则0
	if(a.year>b.year)
	{
		return -1;
	} 
	else if(a.year<b.year)
	{
		return 1;
	}
	else
	{
		if(a.month>b.month)
		{
			return -1;
		}
		else if(a.month<b.month)
		{
			return 1;
		}
		else
		{
			if(a.day>b.day)
			{
				return -1;
			}
			else if(a.day<b.day)
			{
				return 1;
			}
			else
			{
				return 0;
			}
		}
	}
	
} 

int main()
{
	int n;
	char demo[15];
	while(~scanf("%d",&n))
	{
		int num=0;
		int flag=0;
		for(int i=0;i<n;++i)
		{
			scanf("%s%s",temp.name,demo);
			sscanf(demo,"%d/%d/%d",&temp.year,&temp.month,&temp.day);
			
			if(1==test(temp))
			{
				++num;
				
					if(0==flag)
				{
					//第一个合法的 
					init_struct();
					flag=1; 
				}
				
				if(struct_cmp(temp,maxman)==1) 
				{
					strcpy(maxman.name,temp.name);
					maxman.year=temp.year;
					maxman.month=temp.month;
					maxman.day=temp.day;
				}
				
				if(struct_cmp(temp,minman)==-1) 
				{
					strcpy(minman.name,temp.name);
					minman.year=temp.year;
					minman.month=temp.month;
					minman.day=temp.day;
				}
			}
			
			
		}
		
		
		printf("%d %s %s\n",num,maxman.name,minman.name);

	}
	
	
	
	return 0;
} 
```

修改后


```cpp
#include<bits/stdc++.h>
using namespace std;

struct person
{
	char name[6];
	int year;
	int month;
	int day;
}maxman,minman,temp;


void init_struct()
{
	strcpy(maxman.name,temp.name);
	maxman.year=temp.year;
	maxman.month=temp.month;
	maxman.day=temp.day;
	
	strcpy(minman.name,temp.name);
	minman.year=temp.year;
	minman.month=temp.month;
	minman.day=temp.day;
}

//好在在草稿纸上分了情况。。。 
//本来以为还要考虑，闰年啥的，但是似乎，题目说的多少岁，只是简单的年限 
int test(struct person aa)
{
	//是否合法，合法1
	if((aa.year>1814)&&(aa.year<2014)) 
	{
		return 1;
	}
	else if(aa.year==1814)
	{
		if(aa.month>9) 
		{
			return 1;
		}
		else if(9==aa.month)
		{
			if(aa.day>=6)
			{
				return 1;
			}
			else
			{
				return 0;
			}
		}
		else
		{
			return 0;
		}
	}
	else if(aa.year==2014)
	{
		if(aa.month<9)
		{
			return 1;
		}
		else if(aa.month==9)
		{
			if(aa.day<=6)
			{
				return 1;
			}
			else
			{
				return 0;
			}
		}
		else
		{
			return 0; 
		} 
	}
	else
	{
		return 0;
	}
	
	
}


int struct_cmp(struct person a,struct person b)
{
	//比较两个合法，合理的年龄 
	//a比b年长则1，年轻则-1，相同则0
	if(a.year>b.year)
	{
		return -1;
	} 
	else if(a.year<b.year)
	{
		return 1;
	}
	else
	{
		if(a.month>b.month)
		{
			return -1;
		}
		else if(a.month<b.month)
		{
			return 1;
		}
		else
		{
			if(a.day>b.day)
			{
				return -1;
			}
			else if(a.day<b.day)
			{
				return 1;
			}
			else
			{
				return 0;
			}
		}
	}
	
} 

int main()
{
	int n;
	char demo[15];
	while(~scanf("%d",&n))
	{
		int num=0;
		int flag=0;
		for(int i=0;i<n;++i)
		{
			scanf("%s%s",temp.name,demo);
			sscanf(demo,"%d/%d/%d",&temp.year,&temp.month,&temp.day);
			
			if(1==test(temp))
			{
				++num;
				
					if(0==flag)
				{
					//第一个合法的 
					init_struct();
					flag=1; 
				}
				
				if(struct_cmp(temp,maxman)==1) 
				{
					strcpy(maxman.name,temp.name);
					maxman.year=temp.year;
					maxman.month=temp.month;
					maxman.day=temp.day;
				}
				
				if(struct_cmp(temp,minman)==-1) 
				{
					strcpy(minman.name,temp.name);
					minman.year=temp.year;
					minman.month=temp.month;
					minman.day=temp.day;
				}
			}
			
			
		}
		
		
		//修改之处 
		if(0==num)
		{
			printf("%d\n",num);
		}
		else
		{
			printf("%d %s %s\n",num,maxman.name,minman.name);
		}
		

	}
	
	
	
	return 0;
} 
```





## B1029（20）-旧键盘-1016



二、代码

注意，我在提交的时候，写的数组叫hash
虽然本地能过，但是
PAT和牛客后面显示编译错误，后面改为myhash
原因是。哪个头文件包含的太多了，有的命名和某些头文件中冲突了

所以，以后命名不要起，我没用`#include<bits/stdc++.h>`头文件的时候的


都AC
```cpp
#include<bits/stdc++.h>
using namespace std;

int myhash[256]={0};

//表示是否存过，用来去重 
int tag[256]={0};

int test(char c)
{
	if((c>='a')&&(c<='z'))
	{
		//表示是小写字母 
		return 1;
	}
	else
	{
		//表示不是小写字母，不需转化 
		return 0;
	}
	
}


void init(char aa[],int myhash[])
{
	int i=0;
	while(aa[i]!='\0')
	{
		myhash[aa[i]]=1;
		++i;
	}
	
}

int main()
{
	vector<char> solution;
	
	
	char one[81];
	char two[81];
	while(~scanf("%s%s",one,two))
	{
		memset(myhash,0,sizeof(myhash));
		memset(tag,0,sizeof(tag));
		init(two,myhash);
		int i=0;
		int len=strlen(one);
		for(int i=0;i<len;++i)
		{
			if(0==myhash[one[i]])
			{
				//		小写-32就是大写 
				//		printf("%c",'a'-32) ;
				if(test(one[i]))
				{
					
					if(0==tag[one[i]-32])
					{
						solution.push_back(one[i]-32);
					}
					
					
					tag[one[i]-32]=1;
				}
				else
				{
					if(0==tag[one[i]])
					{
						solution.push_back(one[i]);
					}
					tag[one[i]]=1;
				}
			}
		}

		int num=solution.size();
		for(int i=0;i<num;++i)
		{
			printf("%c",solution[i]);
		}
		printf("\n");

	}
	
	
	
	return 0;
}
```





## B1030（25）-完美数列

暴力，、
牛客只显示超时一条，PAT不仅显示了一条超时，还显示了一条某个答案错误
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=100000+1;
int test[maxn]={0};
int n,p;

int max2min(int num,int p)
{
	//表示不OK 
	int flag=0;
	int temp=n-1;
	while(temp-num>-1)
	{
		if(test[temp]<=(test[temp-num]*p))
		{
			flag=1;
			break;
		}
		--temp;
	}
	
	return flag;
} 


int min2max(int num,int p)
{
	//表示不OK 
	int flag=0;
	
	int temp=0;
	while(temp+num<n)
	{
		if(test[temp+num]<=(test[temp]*p))
		{
			flag=1;
			break;
		}
		
		++temp;
	}
	return flag;
}

int main()
{
	
	while(~scanf("%d%d",&n,&p))
	{
		for(int i=0;i<n;++i)
		{
			scanf("%d",&test[i]);
		}
		sort(test,test+n);
		
		int solution=n;
		//从小到大n个尝试 
		//从大到小n个尝试 
		
		do
		{
			if(1==min2max(solution,p)||1==max2min(solution,p))
			{
				break;
			}
			--solution;
		}while(1);
		
		//修正0-7，其实是8个 
		printf("%d\n",solution+1);
	}
	
	
	return 0;
} 
```

双指针

牛客网上AC了，但PAT上显示有一个答案错误
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=100000+1;
int test[maxn]={0};
int n,p;


int main()
{
	
	while(~scanf("%d%d",&n,&p))
	{
		for(int i=0;i<n;++i)
		{
			scanf("%d",&test[i]);
		}
		sort(test,test+n);
		
		int solution=1;
		//双指针法 
		int i=0,j=0;
		while((i<n)&&(j<n))
		{
			while((j<n)&&(test[j]<=(long long)(test[i]*p)))
			{
				solution=max(solution,j-i+1);
				++j;
			}
			++i;
		}
		printf("%d\n",solution);
	}
	
	
	return 0;
} 
```



下面这个却在牛客和PAT上都AC了

```cpp


#include <cstdio>
#include <algorithm>
using namespace std;
const int maxn = 100010;
int n, p, a[maxn];
int main()
{
    scanf("%d%d", &n, &p);
    for(int i = 0; i < n; i++){
        scanf("%d", &a[i]);
    }
    sort(a, a+n);
    int i = 0, j = 0, count = 1;
    while(i < n && j < n){
        while(j < n && a[j] <= (long long)a[i]*p){
            count = max(count, j - i +1);
            j++;
        }
        i++;
    }
    printf("%d\n", count);
    return 0;
}
```

原因

或许是max的原因？？
也似乎没有，我改掉万能头文件
然后，还是不行

后面发现是溢出了
(long long)a[i]*p)
要先转换后乘，而不能乘完再转换，那时候溢出已经发生了。

修改

```cpp
#include<bits/stdc++.h>
 
using namespace std;
const int maxn=100000+1;
int test[maxn]={0};
int n,p;


int main()
{
	
	while(~scanf("%d%d",&n,&p))
	{
		for(int i=0;i<n;++i)
		{
			scanf("%d",&test[i]);
		}
		sort(test,test+n);
		
		int solution=1;
		//双指针法 
		int i=0,j=0;
		while((i<n)&&(j<n))
		{
			while((j<n)&&(test[j]<=p*(long long)test[i]))
			{
				solution=max(solution,j-i+1);
				++j;
			}
			++i;
		}
		printf("%d\n",solution);
	}
	
	
	return 0;
} 
```



## B1031	查验身份证

```cpp
#include<cstdio>
#include<cstring>

char solution[100+1][20];



char last[11]={'1', '0', 'X', '9', '8', '7', '6', '5', '4', '3', '2'};//X的数字是88 

int value[17]={7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2};

int isNum(char c)
{
	if(((c-'0')>=0)&&((c-'0')<=9))
	{
		return c-'0';
	}
	else
	{
		return -1;//表示不是数字 
	}
 } 

int main()
{
	int num;
	scanf("%d",&num);
	int test=1;//1表示通过 
	for(int i=0;i<num;i++)
	{
		scanf("%s",solution[i]);
	}
	
	int sum=0;
	for(int i=0;i<num;i++)
	{
		sum=0;
		int test_sum=1;//1表示求和了17次
		 
		for(int j=0;j<17;j++)
		{
			if(isNum(solution[i][j])>=0)
			{
				sum=sum+value[j]*isNum(solution[i][j]);
				sum%=11;
			}
			else
			{
				test=0;
				test_sum=0; 
				printf("%s\n",solution[i]);
				break;
			}
			
		} 
		
		
		if(test_sum)
		{

			if((last[sum]-solution[i][17])!=0)
			{
				printf("%s\n",solution[i]);
				test=0;
			}
			
		}
		
		
	} 
	
	if(test)
	{
		printf("All passed");
	}
	
	return 0;
}
```





## B1032	挖掘机技术哪家强



```cpp
#include<cstdio>
#include<cstring> 
const int maxn=100000+5;

int solution[maxn]={0};

int main()
{
	int n;
	scanf("%d",&n);
	int a,b;
	
	for(int i=0; i<n; ++i)
	{
		scanf("%d%d",&a,&b);
		solution[a]+=b;
	}
	
	int num=1,value=solution[1];
	
	for(int i=2 ; i<=n ; ++i)
	{
		if(solution[i]>value)
		{
			value=solution[i];
			num=i;
		}
	}
	
	printf("%d %d",num,value);

	return 0;
 } 
```



## 1033	旧键盘打字（ing）



## 1034	有理数四则运算（ing）



## 1035	插入与归并（ing）