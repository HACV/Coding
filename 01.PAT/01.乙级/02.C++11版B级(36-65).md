## B1036	跟奥巴马一起编程

技巧：整数除以2进行四舍五入的操作可以通过判断它是否是奇数来解决，以免浮点数介入。

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int main()
{
	int n;
	char str;
	scanf("%d %c",&n,&str);
	int numm;
	if(n%2){
		numm=n/2+1;
	}
	else
		numm=n/2;
	
	
	for(int i=1;i<=numm;i++)
	{
		if(i==1||i==numm)
		{
			for(int j=1;j<=n;j++)
			{
				printf("%c",str);
			}
		}
		else{
			printf("%c",str);
			for(int j=1;j<=n-2;j++)
			{
				printf(" ");
			}
			printf("%c",str);
		}
		printf("\n");
	}
	
	return 0;
 } 
```





## 1037	在霍格沃茨找零钱（ing）





## **B1038** **统计同成绩学生** **(20**分**)**

**一、思路**

- 格式注意
- hash
- 水题

**二、代码**

```cpp
#include<bits/stdc++.h>
using namespace std;


int main()
{
	int n;
	while( ~scanf("%d",&n) )
	{
		map<int,int> mp;
		int temp;
		while( n-- )
		{
			scanf("%d",&temp);
			mp[temp]++;
		}
		
		int search;
		scanf("%d",&search);
		while( search-- )
		{
			scanf("%d",&temp);
			if( 0==search )
			{
				printf("%d\n",mp[temp]);
			} 
			else
			{
				printf("%d ",mp[temp]);
			}
		}
		
	}
	
	return 0;
}
```





## 1039	到底买不买（ing）



## B1040	有几个PAT

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=100000+1;
char test[maxn]={0};

//当前的左边的P的个数 
int lleft[maxn]={0};
//当前的右边的T的个数 
int rright[maxn]={0};

int main()
{
	while(~scanf("%s",test))
	{
		int len=strlen(test);
		
		if(len<3)
		{
			printf("0\n");
		}
		else
		{
			memset(lleft,0,sizeof(lleft));
			memset(rright,0,sizeof(rright));
			
			for(int i=1;i<len;++i)
			{
				if(test[i-1]=='P')
				{
					//当前的左边的P的个数 
					lleft[i]=lleft[i-1]+1;
				}
				else
				{
					lleft[i]=lleft[i-1];
				}
			}
			
			
			for(int i=len-2;i>=0;--i) 
			{
				if(test[i+1]=='T')
				{
					//当前的右边的T的个数 
					rright[i]=rright[i+1]+1;
				}
				else
				{
					rright[i]=rright[i+1];
				}
			}
			
			long long sum=0;
			
			for(int i=1;i<len;++i) 
			{
				if(test[i]=='A')
				{
					sum=(sum+lleft[i]*rright[i])%1000000007;
				}
			}
			
			printf("%lld\n",sum%1000000007);
		}
		
		
	}
	
	
	return 0;
}
```



## B1041	考试座位号

技巧：由于准考证是14位，可以用long long承载

```cpp
#include<iostream>
#include<vector>
#include<cstdio>
using namespace std;


int test[3][1000+5];


int main()
{
	vector<long long> out;
	int n;
	scanf("%d",&n);
	
	long long temp;
	int one ,two;
	for(int i=0;i<n;i++)
	{
		scanf("%lld%d%d",&temp,&one,&two);
		out.push_back(temp);
		test[1][one]=i;
		test[2][one]=two;
		
	}
	
	int m;
	scanf("%d",&m);
	vector<int> aa;
	int t;
	
	for(int i=0;i<m;i++)
	{
		scanf("%d",&t);
		aa.push_back(t);
	}
	
	for(int i=0;i<m;i++)
	{
		printf("%lld %d",out[test[1][aa[i]]],test[2][aa[i]]);
	
		if(i!=(m-1))
		printf("\n");
		
	}
	
	return 0;
}
```



## 1042	字符统计（ing）



## 1043	输出PATest（ing）



## 1044	火星数字（ing）

## 1045	快速排序（ing）




## B1046	划拳



```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int aa(int sum,int ii,int jj) 
{
	if(sum==ii+jj)
	return 1;
	else
	return 0;
	
}

int test(int a,int one,int c,int two)
{
	//输出1表示，甲输已赢(甲要喝)
	//输出2表示， 。。。
	//输入0，则算了
	if(aa(one,a,c)>aa(two,a,c))
	{
		return 2;
	}
	else if(aa(one,a,c)<aa(two,a,c))
	{
		return 1;
	}
	else
	return 0;
	
	 
}

int main()
{
	int n;
	scanf("%d",&n);
	int a,one,b,two;
	
	int out[2]={0};
	
	for(int i=0;i<n;i++)
	{
		scanf("%d%d%d%d",&a,&one,&b,&two);
		if(test(a,one,b,two)==1)
		{
			out[0]++;
		}
		else if(test(a,one,b,two)==2)
		{
			out[1]++;
		}
	}
	
	printf("%d %d",out[0],out[1]);
	



		
	return 0;	
}
```





## **B1047** **编程团体赛** **(20分)**



一、思路

- hash
- 水题



二、正向迭代器版本-代码

```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
	int n;
	while( ~scanf("%d",&n) )
	{
		map<int,int> mp;
		int temp,bye,num;
		while( n-- )
		{
			scanf("%d%d%d",&temp,&bye,&num);
			mp[temp]+=num;
		}
		
		map<int,int>::iterator it=mp.begin();
		map<int,int>::iterator solve=it;
		
		for(; it!=mp.end(); ++it)
		{
			if( (*it).second > (*solve).second )
			{
				solve=it;
			}
		}
		
		printf("%d %d\n",(*solve).first, (*solve).second );
		
	}
	
	return 0;
}
```



三、反向迭代器版本-代码

```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
	int n;
	while( ~scanf("%d",&n) )
	{
		map<int,int> mp;
		int temp,bye,num;
		while( n-- )
		{
			scanf("%d%d%d",&temp,&bye,&num);
			mp[temp]+=num;
		}
		
        //注意反向迭代器reverse_iterator
		map<int,int>::reverse_iterator it=mp.rbegin();
		map<int,int>::reverse_iterator solve=it;
		
        //注意结束条件是rend()，然后注意是++不是--
		for(; it!=mp.rend(); ++it)
		{
			if( (*it).second > (*solve).second )
			{
				solve=it;
			}
		}
		
		printf("%d %d\n",(*solve).first, (*solve).second );
		
	}
	
	return 0;
}
```





## 1048	数字加密（ing）



## B1049数列的片段和（精度坑）



一、思路和难点

- 精度坑

二、代码

错误思路

我把片段两两一组，组合成一个整的，，，后面发现，整的可以分成很多份啊。。。。

找规律AC 

总结：其实，这些题目不难，但是我似乎编程的时候总是有个想法，要用最优的算法啥的

这样就给自己添加了很多的负担的感觉————————————————@！！！！！！！！



精度问题2

感谢 Ruihan Zheng 对测试数据的修正。
思路：
大人，时代变了！！！
这个题似乎在2020年6月17左右更改了数据和答案，所以说，包括书上的答案，很多大佬写的博客，还有我以前的代码都过不了了。主要的更改的地方是第三个测试点，我猜测主要是浮点数精度的修正。
这个题的作者是CAO, Peng，他的题很多都是需要动点小脑筋的，而不主要是书本上的知识。
通读这个题的题目，感觉蛮复杂的，但是仔细想一下，我们没有必要把每个数列片段全穷举出来。换个思路想想，把所有数列片段混合起来看，每个数共出现过多少次。
————————————————
版权声明：本文为CSDN博主「冰释的温存」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：`https://blog.csdn.net/qq_21394327/java/article/details/106975016`



## 1050	螺旋矩阵（ing）



## 1051	复数乘法（ing）



## 1052	卖个萌（ing）



## 1053	住房空置率（ing）



## 1054	求平均值（ing）



## 1055	集体照（ing）



## B1056	组合数的和

```cpp
#include<iostream>

using namespace std;

int main()
{
	
	int n;
	
	while(cin>>n)
	{
		long long sum=0;
		
		long long temp;
		for(int i=0;i<n;++i)
		{
			cin>>temp;
			sum+=temp;
		}
		
		cout<<sum*(n-1)*(10+1)<<endl;
		
	}
	
	return 0;
	
} 
```





## 1057	数零壹（ing）



## 1058	选择题（ing）



## 1059	C语言竞赛（ing）



## 1060	爱丁顿数（ing）



## B1061	判断题

```cpp
#include<bits/stdc++.h>
using namespace std;

int test[101][102];
int aa[2][101];
int n,m;

void kk()
{
	for(int i=0;i<n;++i)
	{
		test[i][101]=0;
		for(int j=0;j<m;++j)
		{
			if(test[i][j]==aa[1][j])
			{
				test[i][101]+=aa[0][j];
			}
		}
		
		
	}
}

int  main()
{
	
	
	
	while(~scanf("%d%d",&n,&m))
	{
		for(int i=0;i<m;++i)
		{
			scanf("%d",&aa[0][i]);
		}
		for(int i=0;i<m;++i)
		{
			scanf("%d",&aa[1][i]);
		}
		
		for(int i=0;i<n;++i)
		{
			for(int j=0;j<m;++j)
			{
				scanf("%d",&test[i][j]);
			}
		}
		
		
		kk();
		for(int i=0;i<n;++i)
		{
			printf("%d\n",test[i][101]);
		}
		
	}
	
	
	return 0;
}
```



## 1062	最简分数（ing）



## B1063	计算谱半径

```cpp
#include<bits/stdc++.h>
using namespace std;
const double eps=10e-9;

int main()
{
	int n;
	double a,b;
	double c=0,d=0;
	
	while(~scanf("%d",&n))
	{
		for(int i=0;i<n;++i)
		{
			scanf("%lf%lf",&a,&b);
			if(sqrt(a*a+b*b)>sqrt(c*c+d*d))
			{
				c=a;
				d=b;
			}
		}
		
		printf("%.2f\n",sqrt(c*c+d*d));
	}
	
	
	return 0;
} 
```





## B1064	朋友数

```cpp
#include<bits/stdc++.h>
using namespace std;

int tag[40]={0};

int demo(int a)
{
	int su=0;
	while(a!=0)
	{
		su+=a%10;
		a/=10;
	}
	return su;
}

int main()
{
	int n;
	int temp;
	while(~scanf("%d",&n))
	{
		
		for(int i=0;i<n;++i)
		{
			scanf("%d",&temp);
			tag[demo(temp)]=1;
		}
		
		int num=0;
		for(int i=0;i<37;++i)
		{
			if(tag[i]==1)
			{
				++num;
			}
		}
		
		
		printf("%d\n",num);
		
		for(int i=0;i<37;++i)
		{
			if(tag[i]==1)
			{
				if(num==1)
				{
					printf("%d",i);
				}
				else
				{
					printf("%d ",i);
				}
				--num;
			}
		}
		
		memset(tag,0,sizeof(tag));
	}
	
	return 0;
} 
```





## B1065	单身狗

```cpp
#include<bits/stdc++.h>
using namespace std;

//第2行表示出现了 
int tag[100005][2]={0};


int main()
{
	int n;
	while(~scanf("%d",&n))
	{
		memset(tag,-1,sizeof(tag));
		
		for(int i=0;i<n;++i)
		{
			char test[6],kk[6];
			int a=0,b=0;
			scanf("%s%s",test,kk);
			
			int quan=1;
			for(int i=4;i>=0;--i)
			{
				a=a+(test[i]-'0')*quan;
				b=b+(kk[i]-'0')*quan;
				quan*=10;
			}
			
			
			tag[a][0]=b;
			tag[b][0]=a;
		} 
		
		int m;
		scanf("%d",&m);
		for(int i=0;i<m;++i)
		{
			int k;
			scanf("%d",&k);
			tag[k][1]=1;
		}
		
		int num=0;
		for(int i=0;i<100001;++i)
		{
			if((tag[i][1]==1)&&(tag[tag[i][0]][1]!=1))
			{
				++num;
			}
		}
		
		
		printf("%d\n",num);
		for(int i=0;i<100001;++i)
		{
			
			if((tag[i][1]==1)&&(tag[tag[i][0]][1]!=1))
			{
				if(num==1)
				{
					printf("%05d",i);
					break;
				}
				else
				{
					printf("%05d ",i);
				}
				
				--num;
			}
		}
		
		
	}
	
	
	
	return 0;
}
```