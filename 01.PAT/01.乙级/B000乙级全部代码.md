## B1001害死人不偿命的(3n+1)猜想

一、思路和难点

- 无坑
- 简单模拟题目

二、代码

```cpp
#include<cstdio>
int main()
{
	int n;
	scanf("%d",&n);
	int sum;
	for(int i=0;;i++)
	{
		if(n==1)
		{
			sum=i;
			break;
		}
		else if(n%2==0)
		{
			n=n/2;
		}
		else
		{
			n=(3*n+1)/2;
		}
	}
	printf("%d",sum);
	
	return 0;
 } 
```

## B1002写出这个数 (20分)

一、思路和难点

二、代码

```cpp
#include<cstdio>
#include<iostream>
#include<string>
#include<cmath>
using namespace std;
void is(int n)
{
	if(n==0)
	cout<<"ling";
	else if(n==1)
	cout<<"yi";
	else if(n==2)
	cout<<"er";
	else if(n==3)
	cout<<"san";
	else if(n==4)
	cout<<"si";
	else if(n==5)
	cout<<"wu";
	else if(n==6)
	cout<<"liu";
	else if(n==7)
	cout<<"qi";
	else if(n==8)
	cout<<"ba";
	else if(n==9)
	cout<<"jiu";
}

int main()
{
	string str;
	cin>>str;
	int sum=0;
	for(int i=0;i<str.size();i++ )
	{
		sum+=(str[i]-'0');
	}
	
	int test;
	int k=0;
	while(1)
	{
		test=pow(10,k);
		if(sum/test==0)
		break;
		else
		k++;
	}
	
	int aa[k];
	
	for(int i=(k-1);i!=-1;i--)
	{
		aa[i]=sum%10;
		sum=sum/10;
	}
	
	for(int i=0;i<k;i++)
	{
		if(i!=(k-1)) 
		{
			is(aa[i]);	
			cout<<" ";	
		}
		else
			is(aa[i]);	
	}
	
	return 0;
}
//我也不知道为啥是对的，因为在0的时候，没有测试通过
```

## B1003.我要通过

**一、思路和难点**

- 我要通过（题目真心难懂）

**（1）吐槽**

题目真的出的是神马鬼，题意半天我没看懂。。。。

起初当真是没有理解到题目的意图，最基本的想法是按照三部分条件一步一步筛选即可，但是看到第三条就有些蒙圈了。难道是编译原理，自动机？我不禁拿出纸笔画开了图，自动机，自动机。。。妈蛋，这不扯淡呢么，这思路绝不靠谱！OK，于是，回过头来仔细思考，好好打量下这个题目。咦，似乎有一点不同。

**（2）学习**

出题目的人，出完题目之后，最好找人复审一下。不然，学计算机的人，，，，出的题目，似乎有时候真的说的不像是让人能立马听懂，甚至歧义。。。。。。

二、代码











## B1022D进制的A+B (20分)

- 方案和《算法笔记》差不多

```cpp
#include<bits/stdc++.h>
using namespace std;

int a,b,n,len;
int demo[32];
void solve()
{
	int num=a+b;
	len=0;
	while( 0!=(num/n) )
	{
		demo[len++]=num%n;
		num/=n;
	}
	
	demo[len]=num%n;
}

int main()
{
	while( ~scanf("%d%d%d",&a,&b,&n) )
	{
		solve();
		while( len>=0 )
		{
			printf("%d",demo[len--]);
		}
		printf("\n");
	}
	
	return 0;
}
```









## **B1038** **统计同成绩学生** **(20**分**)**

**一、思路**

- 格式注意
- hash
- 水题

**二、代码**

```cpp
#include<bits/stdc++.h>
using namespace std;


int main()
{
	int n;
	while( ~scanf("%d",&n) )
	{
		map<int,int> mp;
		int temp;
		while( n-- )
		{
			scanf("%d",&temp);
			mp[temp]++;
		}
		
		int search;
		scanf("%d",&search);
		while( search-- )
		{
			scanf("%d",&temp);
			if( 0==search )
			{
				printf("%d\n",mp[temp]);
			} 
			else
			{
				printf("%d ",mp[temp]);
			}
		}
		
	}
	
	return 0;
}
```





## **B1047** **编程团体赛** **(20分)**



一、思路

- hash
- 水题



二、正向迭代器版本-代码

```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
	int n;
	while( ~scanf("%d",&n) )
	{
		map<int,int> mp;
		int temp,bye,num;
		while( n-- )
		{
			scanf("%d%d%d",&temp,&bye,&num);
			mp[temp]+=num;
		}
		
		map<int,int>::iterator it=mp.begin();
		map<int,int>::iterator solve=it;
		
		for(; it!=mp.end(); ++it)
		{
			if( (*it).second > (*solve).second )
			{
				solve=it;
			}
		}
		
		printf("%d %d\n",(*solve).first, (*solve).second );
		
	}
	
	return 0;
}
```



三、反向迭代器版本-代码

```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
	int n;
	while( ~scanf("%d",&n) )
	{
		map<int,int> mp;
		int temp,bye,num;
		while( n-- )
		{
			scanf("%d%d%d",&temp,&bye,&num);
			mp[temp]+=num;
		}
		
        //注意反向迭代器reverse_iterator
		map<int,int>::reverse_iterator it=mp.rbegin();
		map<int,int>::reverse_iterator solve=it;
		
        //注意结束条件是rend()，然后注意是++不是--
		for(; it!=mp.rend(); ++it)
		{
			if( (*it).second > (*solve).second )
			{
				solve=it;
			}
		}
		
		printf("%d %d\n",(*solve).first, (*solve).second );
		
	}
	
	return 0;
}
```



## **B1083** **是否存在相等的差** **(20**分)

**一、思路**

- 题目有坑：
  - 1、输出差值大于0的（可以理解）
  - 2、输出出现次数大于1的（题目文字描述的不是这个意思，但是样例是这个意思，先前还以为这个题目出错了）

- 水题

**二、反向迭代器版本-代码**

```cpp
#include<bits/stdc++.h>
using namespace std;


int main()
{
	int n;
	while( ~scanf("%d",&n) )
	{
		map<int,int> mp;
		int cur=1;
		int temp;
		while( n-- )
		{
			scanf("%d",&temp);
			mp[ abs(temp-cur) ]++;
			++cur;
		}
		
		//反向迭代器版本
		map<int,int>::reverse_iterator it=mp.rbegin();
		for(; it!=mp.rend(); ++it)
		{
            //这个题目的坑的地方，就是要至少2个
			if( (*it).second>1 )
			{
				printf("%d %d\n",(*it).first, (*it).second);
			}
		}
	}
	
	return 0;
}
```



## 最后的last