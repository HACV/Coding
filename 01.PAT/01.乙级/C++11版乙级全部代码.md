## B1001 害死人不偿命的(3n+1)猜想

一、思路和难点

- 无坑
- 简单模拟题目

二、代码

```cpp
#include<cstdio>
int main()
{
	int n;
	scanf("%d",&n);
	int sum;
	for(int i=0;;i++)
	{
		if(n==1)
		{
			sum=i;
			break;
		}
		else if(n%2==0)
		{
			n=n/2;
		}
		else
		{
			n=(3*n+1)/2;
		}
	}
	printf("%d",sum);
	
	return 0;
 } 
```

## B1002 写出这个数 (20分)

一、思路和难点

二、代码

```cpp
#include<cstdio>
#include<iostream>
#include<string>
#include<cmath>
using namespace std;
void is(int n)
{
	if(n==0)
	cout<<"ling";
	else if(n==1)
	cout<<"yi";
	else if(n==2)
	cout<<"er";
	else if(n==3)
	cout<<"san";
	else if(n==4)
	cout<<"si";
	else if(n==5)
	cout<<"wu";
	else if(n==6)
	cout<<"liu";
	else if(n==7)
	cout<<"qi";
	else if(n==8)
	cout<<"ba";
	else if(n==9)
	cout<<"jiu";
}

int main()
{
	string str;
	cin>>str;
	int sum=0;
	for(int i=0;i<str.size();i++ )
	{
		sum+=(str[i]-'0');
	}
	
	int test;
	int k=0;
	while(1)
	{
		test=pow(10,k);
		if(sum/test==0)
		break;
		else
		k++;
	}
	
	int aa[k];
	
	for(int i=(k-1);i!=-1;i--)
	{
		aa[i]=sum%10;
		sum=sum/10;
	}
	
	for(int i=0;i<k;i++)
	{
		if(i!=(k-1)) 
		{
			is(aa[i]);	
			cout<<" ";	
		}
		else
			is(aa[i]);	
	}
	
	return 0;
}
//我也不知道为啥是对的，因为在0的时候，没有测试通过
```

## B1003 我要通过

**一、思路和难点**

- 我要通过（题目真心难懂）

**（1）吐槽**

题目真的出的是神马鬼，题意半天我没看懂。。。。

起初当真是没有理解到题目的意图，最基本的想法是按照三部分条件一步一步筛选即可，但是看到第三条就有些蒙圈了。难道是编译原理，自动机？我不禁拿出纸笔画开了图，自动机，自动机。。。妈蛋，这不扯淡呢么，这思路绝不靠谱！OK，于是，回过头来仔细思考，好好打量下这个题目。咦，似乎有一点不同。

**（2）学习**

出题目的人，出完题目之后，最好找人复审一下。不然，学计算机的人，，，，出的题目，似乎有时候真的说的不像是让人能立马听懂，甚至歧义。。。。。。

二、代码





## B1008	数组元素循环右移问题



```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;


int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	
	int aa[n];
	for(int i=0;i<n;i++)
	{
		scanf("%d",&aa[i]);
	}
	
	int s=0;
	//m为偏移量 ,j是用来保障所有数字都被遍历的,s是原始指针 
	for(int j=0;j<n-1;j++,s++)
	{
		printf("%d ",aa[(s-m+100*n)%n]) ;
	}
	
	printf("%d",aa[(s-m+100*n)%n]) ;
//	printf("ss"); 
	return 0;	
}
```





## B1010	一元多项式求导

```cpp
#include<cstdio>
#include<cstring>

int test[2000+5];


int main()
{
	memset(test,-1,sizeof(test));
	
	int a,b;
	int i=0;
	
	while(~scanf("%d%d",&a,&b))
	{
		++i;//表示有i组 
		test[1+(2*(i-1))]=a;
		test[2*i]=b;
		
	}
	
	if(test[2*i]==0)
	{
		i--;
	}
	
	if(i)
	{
		for(int j=1;j<=i;j++)
	{
		printf("%d %d",test[1+(2*(j-1))]*test[2*j],test[2*j]-1);
		
		if(j!=i)
		printf(" ");
	}
	}
	else
	printf("0 0");//这个题目的陷阱所在
	
	return 0;
 } 
```







## B1011  [A+B 和 C](https://pintia.cn/problem-sets/994805260223102976/problems/994805312417021952) 

**一、思路和难点**

简单；

坑点：int+int可能会溢出int，我用的long long 解决



```cpp
#include<iostream>
#include<cstdio>
using namespace std;

int main(){
	
	int n;
	scanf("%d",&n);
	int test[n][4];
	
	long long aa;
	
	for(int i=0;i<n;i++)
	{
		
		scanf("%d%d%d",&test[i][0],&test[i][1],&test[i][2]);
		aa=(long long )test[i][0]+(long long)test[i][1];
		aa=aa-(long long)test[i][2];
		if(aa>0)
		test[i][3]=1;
	}
	
	for(int i=0;i<n-1;i++)
	{
		if(test[i][3]==1)
		{
			printf("Case #%d: true\n",i+1);
		}
		else
		printf("Case #%d: false\n",i+1);
	}
	
	if(test[n-1][3]==1)
	{
		printf("Case #%d: true",n);
	}
	else
		printf("Case #%d: false",n);
	
	return 0;
}
```







## B1012	数字分类

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<cmath>
using namespace std;

vector<int> one,two,four;
int five=-1;
int three=0;

int main()
{

	int n;
	scanf("%d",&n);

	int test;
	for(int i=0;i<n;i++)
	{
		scanf("%d",&test);
		
		if(test%5==0)
		one.push_back(test);
		else if(test%5==1)
		two.push_back(test);
		else if(test%5==2)
		three++;
		else if(test%5==3)
		four.push_back(test);
		else 
		{
			if(test>five)
			five=test;
		}		
	}
	
	int a=one.size();
	int sum=0;
	if(a)
	{
		for(int i=0;i<a;i++)
		{
			if(one[i]%2==0)
			sum+=one[i];
		}
		
		if(sum==0)
			printf("N ");	
		else	
			printf("%d ",sum);
	}
	else
	printf("N ");
	
	
	a=two.size();
	sum=0;
	if(a)
	{
		for(int i=0;i<a;i++)
		{
			sum+=(two[i]*pow(-1,i));
		}
		printf("%d ",sum);
	}
	else
	printf("N ");
	
	
	if(three)
	{
		printf("%d ",three);
	}
	else
	printf("N ");
	
	
	a=four.size();
	sum=0; 
	
	if(a)
	{
		double p;
		for(int i=0;i<a;i++)
		{
			sum+=four[i];
		} 
		p=(double)sum/(double)a;
		printf("%.1f ",p);
		
	 } 
	 else
	printf("N ");	 
	 
	
	if(five>0)
	{
		printf("%d",five);
	}
	else
	printf("N");	 
	 
	 
	 
	
	return 0;
 } 
```






## B1016	部分A+B

**一、思路和难点**

坑点：注意范围

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;

int main(){
	
	long long a,b;
	int one ,two;
	scanf("%lld%d%lld%d",&a,&one,&b,&two);
//schar testone[10+5],testtwo[10+5];
	int s=a%10;	
	int sumone=0;
	while(a/=10)
	{
		if(s==one)
		{
			sumone++;
		}
		s=a%10;
	}
	if(s==one)
	sumone++;
	
	int ss=b%10;	
	int sumtwo=0;
	while(b/=10)
	{
		if(ss==two)
		{
			sumtwo++;
		}
		ss=b%10;
	}
	
	if(ss==two)
	sumtwo++;
	
	long long int Tone=0,Ttwo=0;
	for(int i=0;i<sumone;i++)
	{
		Tone+=(long long )one*pow(10,i);
	}
	
	for(int i=0;i<sumtwo;i++)
	{
		Ttwo+=(long long )two*pow(10,i);
	}
//		cout<<Tone<<endl;
//		cout<<Ttwo<<endl;
	long long cc=(long long)Tone+(long long)Ttwo;
	printf("%lld",cc);

		

	return 0;
}
```



## B1018	锤子剪刀布

格式好题。

注意格式：getchar的使用

由于scanf使用%c时会将换行符\n读入，因此需要在合适的地方用getchar吸收空格，否则会导致读入与题意不太符合——程序输入数据后闪退，基本上就是这个问题导致的。



````cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<cmath>
using namespace std;

int test(char aa,char bb)
{
	//0表示平手
	//-1表  甲win 
	if(aa=='B'&&bb=='B')
	return 0;
	else if(aa=='C'&&bb=='C')
	return 0;
	else if(aa=='J'&&bb=='J') 
	return 0;
	else if(aa=='B'&&bb=='C')
	return -1;
	else if(aa=='B'&&bb=='J')
	return 1;
	else if(aa=='C'&&bb=='J')
	return -1;
	else if(aa=='C'&&bb=='B')
	return 1;
	else if(aa=='J'&&bb=='B')
	return -1;
	else//JheC 
	return 1;
	
	
	
}

int main()
{

	int n;
	scanf("%d",&n);

	int a[3]={0};//0胜，1平，2负
	int b[3]={0};
	
	int a_one[3]={0};//0表示B布，1表示C锤子，2表示剪刀
	int b_two[3]={0};
	
	char aa,bb; 
	getchar();//易错 
	for(int i=0;i<n;i++)
	{
		scanf("%c %c",&aa,&bb);
		
		getchar();
		
//		printf("%c %c",aa,bb);
		if(test(aa,bb)==0)
		{
			a[1]++;
			b[1]++;
		}
		else if(test(aa,bb)==-1)
		{
			a[0]++;
			b[2]++;
			if(aa=='B')
			a_one[0]++;
			else if(aa=='C')
			a_one[1]++;
			else 
			a_one[2]++;
		}
		else 
		{
			b[0]++;
			a[2]++;
			if(bb=='B')
			b_two[0]++;
			else if(bb=='C')
			b_two[1]++;
			else 
			b_two[2]++;
		}
		
	}
	
	printf("%d %d %d\n",a[0],a[1],a[2]);
	printf("%d %d %d\n",b[0],b[1],b[2]);
	
	int out=a_one[0];
	
	int j=0;
	for(int i=1;i<3;i++)
	{
		if(a_one[i]>out)
		{
			j=i;
			out=a_one[i];
		}
	}
	
	if(j==0)
	printf("B ");
	else if(j==1)
	printf("C ");
	else
	printf("J ");
	
	
	
	out=b_two[0];
	
	j=0;
	for(int i=1;i<3;i++)
	{
		if(b_two[i]>out)
		{
			j=i;
			out=b_two[i];
		}
	}
	
	if(j==0)
	printf("B");
	else if(j==1)
	printf("C");
	else
	printf("J");
	

	
	return 0;
 } 
````







## B1022 D进制的A+B (20分)

- 方案和《算法笔记》差不多

```cpp
#include<bits/stdc++.h>
using namespace std;

int a,b,n,len;
int demo[32];
void solve()
{
	int num=a+b;
	len=0;
	while( 0!=(num/n) )
	{
		demo[len++]=num%n;
		num/=n;
	}
	
	demo[len]=num%n;
}

int main()
{
	while( ~scanf("%d%d%d",&a,&b,&n) )
	{
		solve();
		while( len>=0 )
		{
			printf("%d",demo[len--]);
		}
		printf("\n");
	}
	
	return 0;
}
```





## B1026	程序运行时间

坑点：注意，输出格式

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;


int main()
{
	int a,b;
	scanf("%d%d",&a,&b);
	
	int sum=(int)round((double)(b-a)/100);
		
	int s=sum%3600; 
	
	int one=(sum/=3600);//小时 
	
	int three=s%60;//秒钟 
	
	int two=(s/60);//fen
	
	if(one>=10)
	{
		printf("%d:",one);
	}
	else
	{
		printf("0%d:",one);
	}
	
	if(two>=10)
	{
		printf("%d:",two);
	}
	else
	{
		printf("0%d:",two);
	}
	
	if(three>=10)
	{
		printf("%d",three);
	}
	else
	{
		printf("0%d",three);
	}
		
	return 0;	
}

	
```



餐考代码

1）四舍五入可以用math.h中的round函数，但是由于涉及浮点数会使写法变得复杂，因此不妨直接通过判断c2-c1的后2位来判断是四舍还是勿入，以避免浮点数运算

2）时分秒的输出要保证不足2位时高位补0，

```cpp
#include<bits/stdc++.h>
using namespace std;


int main()
{
	
	int c1,c2;
	scanf("%d%d",&c1,&c2);

	int ans=c2-c1;

	if( ans %100 >=50)
	{
		ans=ans/100+1;
	}
	else
	{
		ans=ans/100;
	}

	printf("%02d:%02d:%02d\n",ans/3600,ans%3600/60,ans%60);
	
	return 0;
 } 

```









## B1027 打印沙漏20 

```cpp



## 二、代码

求多少行，通项公式
Sn和


考点：模拟
坑点：n=1只输出一个符号的时候的边界，要注意

PAT和牛客都AC

​```cpp
#include<bits/stdc++.h>
using namespace std;



int solution(int n)
{
	int num=25;
	
	for(;num>0;--num)
	{
		if(2*num*num<=n)
		{
			break;
		}
	}
	
	return num;
}

void test(int num,char c)
{
	//uploop
	int up_loop=num;
	int up_num=2*num-1;
	
	//down loop
	int down_loop=num-1;
	int down_num=3;
	
	//前面空格的个数 
	int count=0;
	for( ;up_loop>0 ;  )
	{
		for(int i=0;i<count;++i)
		{
			printf(" ");
		}
		
		
		
		for(int i=0;i<up_num;++i)
		{
			printf("%c",c);
		}
		printf("\n");
		
		//下次空格 
		++count;
		//下次符号 
		up_num-=2;
		//还剩下的循环 
		--up_loop; 
	}
	
	count-=2;
	
	for( ;down_loop>0 ;  )
	{
		for(int i=0;i<count;++i)
		{
			printf(" ");
		}
		
		
		
		for(int i=0;i<down_num;++i)
		{
			printf("%c",c);
		}
		printf("\n");
		
		//下次空格 
		--count;
		//下次符号 
		down_num+=2;
		//还剩下的循环 
		--down_loop; 
	}
	
}


int main()
{
	int n;
	char c;
	while(~scanf("%d %c",&n,&c))
	{
		int num=solution(n);
		if(0!=num) 
		{
			test(num,c);
			printf("%d\n",n-(2*num*num-1));
		}
		else
		{
			//表示n=1
			printf("%c\n",c); 
			printf("0\n");
		}
		
		
	}
	
	return 0;
}
```



## B1028人口普查



二、代码



牛客上AC了，但是PAT上显示部分正确（格式错误）

其实牛客上忽略了一个东西。那就是合理的生日数目要是是0，那么就没有人名输出
```cpp
#include<bits/stdc++.h>
using namespace std;

struct person
{
	char name[6];
	int year;
	int month;
	int day;
}maxman,minman,temp;


void init_struct()
{
	strcpy(maxman.name,temp.name);
	maxman.year=temp.year;
	maxman.month=temp.month;
	maxman.day=temp.day;
	
	strcpy(minman.name,temp.name);
	minman.year=temp.year;
	minman.month=temp.month;
	minman.day=temp.day;
}

//好在在草稿纸上分了情况。。。 
//本来以为还要考虑，闰年啥的，但是似乎，题目说的多少岁，只是简单的年限 
int test(struct person aa)
{
	//是否合法，合法1
	if((aa.year>1814)&&(aa.year<2014)) 
	{
		return 1;
	}
	else if(aa.year==1814)
	{
		if(aa.month>9) 
		{
			return 1;
		}
		else if(9==aa.month)
		{
			if(aa.day>=6)
			{
				return 1;
			}
			else
			{
				return 0;
			}
		}
		else
		{
			return 0;
		}
	}
	else if(aa.year==2014)
	{
		if(aa.month<9)
		{
			return 1;
		}
		else if(aa.month==9)
		{
			if(aa.day<=6)
			{
				return 1;
			}
			else
			{
				return 0;
			}
		}
		else
		{
			return 0; 
		} 
	}
	else
	{
		return 0;
	}
	
	
}


int struct_cmp(struct person a,struct person b)
{
	//比较两个合法，合理的年龄 
	//a比b年长则1，年轻则-1，相同则0
	if(a.year>b.year)
	{
		return -1;
	} 
	else if(a.year<b.year)
	{
		return 1;
	}
	else
	{
		if(a.month>b.month)
		{
			return -1;
		}
		else if(a.month<b.month)
		{
			return 1;
		}
		else
		{
			if(a.day>b.day)
			{
				return -1;
			}
			else if(a.day<b.day)
			{
				return 1;
			}
			else
			{
				return 0;
			}
		}
	}
	
} 

int main()
{
	int n;
	char demo[15];
	while(~scanf("%d",&n))
	{
		int num=0;
		int flag=0;
		for(int i=0;i<n;++i)
		{
			scanf("%s%s",temp.name,demo);
			sscanf(demo,"%d/%d/%d",&temp.year,&temp.month,&temp.day);
			
			if(1==test(temp))
			{
				++num;
				
					if(0==flag)
				{
					//第一个合法的 
					init_struct();
					flag=1; 
				}
				
				if(struct_cmp(temp,maxman)==1) 
				{
					strcpy(maxman.name,temp.name);
					maxman.year=temp.year;
					maxman.month=temp.month;
					maxman.day=temp.day;
				}
				
				if(struct_cmp(temp,minman)==-1) 
				{
					strcpy(minman.name,temp.name);
					minman.year=temp.year;
					minman.month=temp.month;
					minman.day=temp.day;
				}
			}
			
			
		}
		
		
		printf("%d %s %s\n",num,maxman.name,minman.name);

	}
	
	
	
	return 0;
} 
```

修改后


```cpp
#include<bits/stdc++.h>
using namespace std;

struct person
{
	char name[6];
	int year;
	int month;
	int day;
}maxman,minman,temp;


void init_struct()
{
	strcpy(maxman.name,temp.name);
	maxman.year=temp.year;
	maxman.month=temp.month;
	maxman.day=temp.day;
	
	strcpy(minman.name,temp.name);
	minman.year=temp.year;
	minman.month=temp.month;
	minman.day=temp.day;
}

//好在在草稿纸上分了情况。。。 
//本来以为还要考虑，闰年啥的，但是似乎，题目说的多少岁，只是简单的年限 
int test(struct person aa)
{
	//是否合法，合法1
	if((aa.year>1814)&&(aa.year<2014)) 
	{
		return 1;
	}
	else if(aa.year==1814)
	{
		if(aa.month>9) 
		{
			return 1;
		}
		else if(9==aa.month)
		{
			if(aa.day>=6)
			{
				return 1;
			}
			else
			{
				return 0;
			}
		}
		else
		{
			return 0;
		}
	}
	else if(aa.year==2014)
	{
		if(aa.month<9)
		{
			return 1;
		}
		else if(aa.month==9)
		{
			if(aa.day<=6)
			{
				return 1;
			}
			else
			{
				return 0;
			}
		}
		else
		{
			return 0; 
		} 
	}
	else
	{
		return 0;
	}
	
	
}


int struct_cmp(struct person a,struct person b)
{
	//比较两个合法，合理的年龄 
	//a比b年长则1，年轻则-1，相同则0
	if(a.year>b.year)
	{
		return -1;
	} 
	else if(a.year<b.year)
	{
		return 1;
	}
	else
	{
		if(a.month>b.month)
		{
			return -1;
		}
		else if(a.month<b.month)
		{
			return 1;
		}
		else
		{
			if(a.day>b.day)
			{
				return -1;
			}
			else if(a.day<b.day)
			{
				return 1;
			}
			else
			{
				return 0;
			}
		}
	}
	
} 

int main()
{
	int n;
	char demo[15];
	while(~scanf("%d",&n))
	{
		int num=0;
		int flag=0;
		for(int i=0;i<n;++i)
		{
			scanf("%s%s",temp.name,demo);
			sscanf(demo,"%d/%d/%d",&temp.year,&temp.month,&temp.day);
			
			if(1==test(temp))
			{
				++num;
				
					if(0==flag)
				{
					//第一个合法的 
					init_struct();
					flag=1; 
				}
				
				if(struct_cmp(temp,maxman)==1) 
				{
					strcpy(maxman.name,temp.name);
					maxman.year=temp.year;
					maxman.month=temp.month;
					maxman.day=temp.day;
				}
				
				if(struct_cmp(temp,minman)==-1) 
				{
					strcpy(minman.name,temp.name);
					minman.year=temp.year;
					minman.month=temp.month;
					minman.day=temp.day;
				}
			}
			
			
		}
		
		
		//修改之处 
		if(0==num)
		{
			printf("%d\n",num);
		}
		else
		{
			printf("%d %s %s\n",num,maxman.name,minman.name);
		}
		

	}
	
	
	
	return 0;
} 
```





## B1029（20）-旧键盘-1016



二、代码

注意，我在提交的时候，写的数组叫hash
虽然本地能过，但是
PAT和牛客后面显示编译错误，后面改为myhash
原因是。哪个头文件包含的太多了，有的命名和某些头文件中冲突了

所以，以后命名不要起，我没用`#include<bits/stdc++.h>`头文件的时候的


都AC
```cpp
#include<bits/stdc++.h>
using namespace std;

int myhash[256]={0};

//表示是否存过，用来去重 
int tag[256]={0};

int test(char c)
{
	if((c>='a')&&(c<='z'))
	{
		//表示是小写字母 
		return 1;
	}
	else
	{
		//表示不是小写字母，不需转化 
		return 0;
	}
	
}


void init(char aa[],int myhash[])
{
	int i=0;
	while(aa[i]!='\0')
	{
		myhash[aa[i]]=1;
		++i;
	}
	
}

int main()
{
	vector<char> solution;
	
	
	char one[81];
	char two[81];
	while(~scanf("%s%s",one,two))
	{
		memset(myhash,0,sizeof(myhash));
		memset(tag,0,sizeof(tag));
		init(two,myhash);
		int i=0;
		int len=strlen(one);
		for(int i=0;i<len;++i)
		{
			if(0==myhash[one[i]])
			{
				//		小写-32就是大写 
				//		printf("%c",'a'-32) ;
				if(test(one[i]))
				{
					
					if(0==tag[one[i]-32])
					{
						solution.push_back(one[i]-32);
					}
					
					
					tag[one[i]-32]=1;
				}
				else
				{
					if(0==tag[one[i]])
					{
						solution.push_back(one[i]);
					}
					tag[one[i]]=1;
				}
			}
		}

		int num=solution.size();
		for(int i=0;i<num;++i)
		{
			printf("%c",solution[i]);
		}
		printf("\n");

	}
	
	
	
	return 0;
}
```





## B1030（25）-完美数列

暴力，、
牛客只显示超时一条，PAT不仅显示了一条超时，还显示了一条某个答案错误
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=100000+1;
int test[maxn]={0};
int n,p;

int max2min(int num,int p)
{
	//表示不OK 
	int flag=0;
	int temp=n-1;
	while(temp-num>-1)
	{
		if(test[temp]<=(test[temp-num]*p))
		{
			flag=1;
			break;
		}
		--temp;
	}
	
	return flag;
} 


int min2max(int num,int p)
{
	//表示不OK 
	int flag=0;
	
	int temp=0;
	while(temp+num<n)
	{
		if(test[temp+num]<=(test[temp]*p))
		{
			flag=1;
			break;
		}
		
		++temp;
	}
	return flag;
}

int main()
{
	
	while(~scanf("%d%d",&n,&p))
	{
		for(int i=0;i<n;++i)
		{
			scanf("%d",&test[i]);
		}
		sort(test,test+n);
		
		int solution=n;
		//从小到大n个尝试 
		//从大到小n个尝试 
		
		do
		{
			if(1==min2max(solution,p)||1==max2min(solution,p))
			{
				break;
			}
			--solution;
		}while(1);
		
		//修正0-7，其实是8个 
		printf("%d\n",solution+1);
	}
	
	
	return 0;
} 
```

双指针

牛客网上AC了，但PAT上显示有一个答案错误
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=100000+1;
int test[maxn]={0};
int n,p;


int main()
{
	
	while(~scanf("%d%d",&n,&p))
	{
		for(int i=0;i<n;++i)
		{
			scanf("%d",&test[i]);
		}
		sort(test,test+n);
		
		int solution=1;
		//双指针法 
		int i=0,j=0;
		while((i<n)&&(j<n))
		{
			while((j<n)&&(test[j]<=(long long)(test[i]*p)))
			{
				solution=max(solution,j-i+1);
				++j;
			}
			++i;
		}
		printf("%d\n",solution);
	}
	
	
	return 0;
} 
```



下面这个却在牛客和PAT上都AC了

```cpp


#include <cstdio>
#include <algorithm>
using namespace std;
const int maxn = 100010;
int n, p, a[maxn];
int main()
{
    scanf("%d%d", &n, &p);
    for(int i = 0; i < n; i++){
        scanf("%d", &a[i]);
    }
    sort(a, a+n);
    int i = 0, j = 0, count = 1;
    while(i < n && j < n){
        while(j < n && a[j] <= (long long)a[i]*p){
            count = max(count, j - i +1);
            j++;
        }
        i++;
    }
    printf("%d\n", count);
    return 0;
}
```

原因

或许是max的原因？？
也似乎没有，我改掉万能头文件
然后，还是不行

后面发现是溢出了
(long long)a[i]*p)
要先转换后乘，而不能乘完再转换，那时候溢出已经发生了。

修改

```cpp
#include<bits/stdc++.h>
 
using namespace std;
const int maxn=100000+1;
int test[maxn]={0};
int n,p;


int main()
{
	
	while(~scanf("%d%d",&n,&p))
	{
		for(int i=0;i<n;++i)
		{
			scanf("%d",&test[i]);
		}
		sort(test,test+n);
		
		int solution=1;
		//双指针法 
		int i=0,j=0;
		while((i<n)&&(j<n))
		{
			while((j<n)&&(test[j]<=p*(long long)test[i]))
			{
				solution=max(solution,j-i+1);
				++j;
			}
			++i;
		}
		printf("%d\n",solution);
	}
	
	
	return 0;
} 
```





## **B1038** **统计同成绩学生** **(20**分**)**

**一、思路**

- 格式注意
- hash
- 水题

**二、代码**

```cpp
#include<bits/stdc++.h>
using namespace std;


int main()
{
	int n;
	while( ~scanf("%d",&n) )
	{
		map<int,int> mp;
		int temp;
		while( n-- )
		{
			scanf("%d",&temp);
			mp[temp]++;
		}
		
		int search;
		scanf("%d",&search);
		while( search-- )
		{
			scanf("%d",&temp);
			if( 0==search )
			{
				printf("%d\n",mp[temp]);
			} 
			else
			{
				printf("%d ",mp[temp]);
			}
		}
		
	}
	
	return 0;
}
```



## B1046	划拳



```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int aa(int sum,int ii,int jj) 
{
	if(sum==ii+jj)
	return 1;
	else
	return 0;
	
}

int test(int a,int one,int c,int two)
{
	//输出1表示，甲输已赢(甲要喝)
	//输出2表示， 。。。
	//输入0，则算了
	if(aa(one,a,c)>aa(two,a,c))
	{
		return 2;
	}
	else if(aa(one,a,c)<aa(two,a,c))
	{
		return 1;
	}
	else
	return 0;
	
	 
}

int main()
{
	int n;
	scanf("%d",&n);
	int a,one,b,two;
	
	int out[2]={0};
	
	for(int i=0;i<n;i++)
	{
		scanf("%d%d%d%d",&a,&one,&b,&two);
		if(test(a,one,b,two)==1)
		{
			out[0]++;
		}
		else if(test(a,one,b,two)==2)
		{
			out[1]++;
		}
	}
	
	printf("%d %d",out[0],out[1]);
	



		
	return 0;	
}
```





## **B1047** **编程团体赛** **(20分)**



一、思路

- hash
- 水题



二、正向迭代器版本-代码

```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
	int n;
	while( ~scanf("%d",&n) )
	{
		map<int,int> mp;
		int temp,bye,num;
		while( n-- )
		{
			scanf("%d%d%d",&temp,&bye,&num);
			mp[temp]+=num;
		}
		
		map<int,int>::iterator it=mp.begin();
		map<int,int>::iterator solve=it;
		
		for(; it!=mp.end(); ++it)
		{
			if( (*it).second > (*solve).second )
			{
				solve=it;
			}
		}
		
		printf("%d %d\n",(*solve).first, (*solve).second );
		
	}
	
	return 0;
}
```



三、反向迭代器版本-代码

```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
	int n;
	while( ~scanf("%d",&n) )
	{
		map<int,int> mp;
		int temp,bye,num;
		while( n-- )
		{
			scanf("%d%d%d",&temp,&bye,&num);
			mp[temp]+=num;
		}
		
        //注意反向迭代器reverse_iterator
		map<int,int>::reverse_iterator it=mp.rbegin();
		map<int,int>::reverse_iterator solve=it;
		
        //注意结束条件是rend()，然后注意是++不是--
		for(; it!=mp.rend(); ++it)
		{
			if( (*it).second > (*solve).second )
			{
				solve=it;
			}
		}
		
		printf("%d %d\n",(*solve).first, (*solve).second );
		
	}
	
	return 0;
}
```





## B1049数列的片段和（精度坑）



一、思路和难点

- 精度坑

二、代码

错误思路

我把片段两两一组，组合成一个整的，，，后面发现，整的可以分成很多份啊。。。。

找规律AC 

总结：其实，这些题目不难，但是我似乎编程的时候总是有个想法，要用最优的算法啥的

这样就给自己添加了很多的负担的感觉————————————————@！！！！！！！！



精度问题2

感谢 Ruihan Zheng 对测试数据的修正。
思路：
大人，时代变了！！！
这个题似乎在2020年6月17左右更改了数据和答案，所以说，包括书上的答案，很多大佬写的博客，还有我以前的代码都过不了了。主要的更改的地方是第三个测试点，我猜测主要是浮点数精度的修正。
这个题的作者是CAO, Peng，他的题很多都是需要动点小脑筋的，而不主要是书本上的知识。
通读这个题的题目，感觉蛮复杂的，但是仔细想一下，我们没有必要把每个数列片段全穷举出来。换个思路想想，把所有数列片段混合起来看，每个数共出现过多少次。
————————————————
版权声明：本文为CSDN博主「冰释的温存」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：`https://blog.csdn.net/qq_21394327/java/article/details/106975016`



## **B1083** **是否存在相等的差** **(20**分)

**一、思路**

- 题目有坑：
  - 1、输出差值大于0的（可以理解）
  - 2、输出出现次数大于1的（题目文字描述的不是这个意思，但是样例是这个意思，先前还以为这个题目出错了）

- 水题

**二、反向迭代器版本-代码**

```cpp
#include<bits/stdc++.h>
using namespace std;


int main()
{
	int n;
	while( ~scanf("%d",&n) )
	{
		map<int,int> mp;
		int cur=1;
		int temp;
		while( n-- )
		{
			scanf("%d",&temp);
			mp[ abs(temp-cur) ]++;
			++cur;
		}
		
		//反向迭代器版本
		map<int,int>::reverse_iterator it=mp.rbegin();
		for(; it!=mp.rend(); ++it)
		{
            //这个题目的坑的地方，就是要至少2个
			if( (*it).second>1 )
			{
				printf("%d %d\n",(*it).first, (*it).second);
			}
		}
	}
	
	return 0;
}
```



## 最后的last