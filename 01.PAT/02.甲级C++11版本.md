
# PTA上A级


注意，我自己习惯用的多组输入输出在PAT的败北（要注意！！！！！！总结）



## A1001 A+B Format (20分)

一、思路和难点



二、代码（别人的）

```cpp
#include <iostream>
#include <stack>
using namespace std;
int main()
{
    stack <int> s;
    long int a,b,x;
    int bool_1=0;
    int j=0,k=0;
    cin>>a>>b;
    x=a+b;

   if(x==0)
   {
       cout<<x;
       return 0;
   }
    
    if(x<0)
    {
        x=x*(-1);
        bool_1=1;
    }
    while(x)
    {
        s.push(x%10);
        x/=10;
        j++;
    }
    while (!s.empty())
    {
        if(bool_1==1)
        {
              cout<<'-';
              bool_1=0;
        }
        j--;
        cout<<s.top();
        s.pop();

        if(j%3==0&&j!=0)
            cout<<',';
    }
    return 0;
}
```



## A1006	Sign In and Sign Out

不是最优，但是排序的解法

或许解释了，如果是24小时制的排序比，12小时但是am和pm更好排序。

```cpp
#include<bits/stdc++.h>
using namespace std;

int n;
struct node
{
	char name[20];
	int downA,downB,downC;
	int upA,upB,upC;
};

bool LessCmp(node a, node b)
{
	if( a.downA!=b.downA )
	{
		return a.downA<b.downA;
	}
	else
	{
		if( a.downB!=b.downB )
		{
			return a.downB<b.downB;
		}
		else
		{
			return a.downC<b.downC;

		}

	}
}

bool UpCmp(node a, node b)
{
	if( a.upA!=b.upA )
	{
		return a.upA>b.upA;
	}
	else
	{
		if( a.upB!=b.upB )
		{
			return a.upB>b.upB;
		}
		else
		{
			return a.upC>b.upC;
		}

	}
}

int main()
{

	while( ~scanf("%d",&n ) )
	{
		vector<node> solve;
		while(n--)
		{
			node temp;
			scanf("%s %d:%d:%d %d:%d:%d", temp.name, 
			&temp.downA, &temp.downB, &temp.downC, &temp.upA, &temp.upB, &temp.upC);

			solve.push_back(temp);
		}

		sort( solve.begin(), solve.end(), LessCmp);
		printf("%s ",solve[0].name);

		sort( solve.begin(), solve.end(), UpCmp);
		printf("%s\n",solve[0].name);
	}

	return 0;
}
```





## A1011	World Cup Betting



虽然AC了，但是double的比较有瑕疵

```cpp
#include<bits/stdc++.h>
using namespace std;

unordered_map<int,char> mp;
void init()
{
	mp[0]='W';
	mp[1]='T';
	mp[2]='L';
}

int main()
{
	init();
	double ans=1.0;
	double solve[3]={0.0};

	for(int i=0; i<3; ++i)
	{
		double temp;
		int index=0;
		for(int j=0; j<3; ++j)
		{
			scanf("%lf",&temp);
			if( temp>solve[i] )
			{
				solve[i]=temp;
				index=j;
			}
		}

		printf("%c ",mp[index] );
	}
	
	ans=ans*(solve[0]*solve[1]*solve[2]*0.65-1)*2;
	printf("%.2lf\n", ans );

	return 0;
}
```



## A1027 [Colors in Mars](https://pintia.cn/problem-sets/994805342720868352/problems/994805470349344768) 

- 水题
- 但是，要注意输出格式。
- 当然，这题，最简洁的代码显然是『打表』，但是我暂时先训练STL，打表，以后增加

```cpp
#include<bits/stdc++.h>
using namespace std;

map<int,char> mp;
void init()
{
	for(int i=0; i<10; ++i)
	{
		mp[i]='0'+i;
	}
	mp[10]='A';
	mp[11]='B';
	mp[12]='C';
}


void solve(int n)
{
	//坑点1，不足2位，要输出两位格式
	if( 0==n )
	{
		printf("00");
		return;
	}

	stack<char> st;
    //下面这个代码，可以说是『求进制转换的模板』，这个while循环要非常熟练
	while( n )
	{
		st.push( mp[n%13] );
		n/=13;
	}

	//坑点1，不足2位，要输出两位格式
	if( 2!=st.size() )
	{
		printf("0");
	}

	while( !st.empty() )
	{
		printf("%c",st.top() );
		st.pop();
	}

}

int main()
{
	int a,b,c;
	init();
	while( ~scanf("%d%d%d",&a,&b,&c) )
	{
		printf("#");
		solve(a);
		solve(b);
		solve(c);
		printf("\n");
	}

	return 0;
}
```







## A1031 | [Hello World for U](https://pintia.cn/problem-sets/994805342720868352/problems/994805462535356416) 

- 水题
- 余数的使用，数学的考法

```cpp
#include<bits/stdc++.h>
using namespace std;


static const int maxn=1e5+5;
char solve[maxn];

int main()
{

	while( ~scanf("%s",solve) )
	{
		int len=strlen( solve );
		int L=0,R=len-1,down;
		int loop=L;
		if( 0== (len+2)%3 )
		{
			down=loop=(len+2)/3;
		}
		else
		{
			loop=(len+2)/3;
			down=loop+(len+2)%3;
		}

		int TagTemp=down-2;
		--loop;
		while( loop-- )
		{
			printf("%c",solve[L++]);
			int tag=TagTemp;
			while( tag-- )
			{
				printf(" ");
			}
			printf("%c\n",solve[R--]);
		}

		while( down-- )
		{
			printf("%c",solve[L++]);
		}
		printf("\n");
	}

	return 0;
}

```







## A1036（多组输入输出在PAT——神奇的败北之地）



两种写法都是，如果break;//不写就会超时，写了就不超时。。。。。竟然和秋招不一样。和牛客不一样。。。

**1.。用的sort**

```cpp
#include<bits/stdc++.h>
using namespace std;

int n;
struct node
{
	char name[30];
	char gender;//性别
	char message[30];
	int val;
};

bool cmp( node a, node b)
{
	return a.val<b.val;
}

int main()
{

	while( scanf("%d",&n) )
	{
		vector<node> female;
		vector<node> male;

		while( n-- )
		{
			node temp;
			scanf("%s %c %s %d",temp.name, &temp.gender, temp.message, &temp.val );

			if( 'F'==temp.gender )
			{
				female.push_back( temp );
			}
			else
			{
				male.push_back( temp );
			}
            //cout<<"OK"<<endl;
		}

		sort( female.begin(), female.end(), cmp);
		sort( male.begin(), male.end(), cmp);

		int tag=0;//表示都有
		int maxFemale,minMale;
		if( 0==female.size() )
		{
			tag=1;
			printf("Absent\n");
		}
		else
		{
			auto it=female.rbegin();
			maxFemale=(*it).val;
			printf("%s %s\n", (*it).name, (*it).message );
		}


		if( 0==male.size() )
		{
			tag=1;
			printf("Absent\n");
		}
		else
		{
			auto it=male.begin();
			minMale=(*it).val;
			printf("%s %s\n", (*it).name, (*it).message );
		}

		if( tag )
		{
			printf("NA\n");
		}
		else
		{
			printf("%d\n", maxFemale-minMale );
		}
		break;//不写就会超时，写了就不超时。。。。。竟然和秋招不一样。和牛客不一样。。。
	}


	return 0;
}
```



**2.。用的临时变量解法**

```cpp
#include<bits/stdc++.h>
using namespace std;

int n;
struct node
{
	char name[30];
	char gender;//性别
	char message[30];
	int val;

	node(){};
};

void cpy( node &really, node &ctor)
{
	strcpy(really.name, ctor.name);
	really.gender=ctor.gender;
	strcpy(really.message,ctor.message);
	really.val=ctor.val;
}

bool cmp( node a, node b)
{
	return a.val<b.val;
}

int main()
{

	while( scanf("%d",&n) )
	{
		node female;
		female.val=-1;
		node male;
		male.val=0x3f3f;

		while( n-- )
		{
			node temp;
			scanf("%s %c %s %d",temp.name, &temp.gender, temp.message, &temp.val );

			if( 'F'==temp.gender )
			{
				if( temp.val>female.val )
				{
					cpy( female, temp);
				}
			}
			else
			{
				if( temp.val<male.val )
				{
					cpy( male, temp);
				}
			}
            
		}


		int tag=0;//表示都有
		int maxFemale,minMale;
		if( -1==female.val )
		{
			tag=1;
			printf("Absent\n");
		}
		else
		{
			maxFemale=female.val;
			printf("%s %s\n", female.name, female.message );
		}


		if( 0x3f3f==male.val )
		{
			tag=1;
			printf("Absent\n");
		}
		else
		{
			minMale=male.val;
			printf("%s %s\n", male.name, male.message );
		}

		if( tag )
		{
			printf("NA\n");
		}
		else
		{
			printf("%d\n", maxFemale-minMale );
		}
        break;//不写就会超时，写了就不超时。。。。。竟然和秋招不一样。和牛客不一样。。。
	}


	return 0;
}
```







## A1042	Shuffling Machine

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<cmath>
#include<algorithm> 
using namespace std;

struct node{
	char c;
	int num;
	int x;//表示当前位置
	 
}test[54]; 

bool cmp(node a,node b) 
{
	return a.x<b.x;//按照x的值，从小到大 
}


int kk[54];

int main()
{

	int s=0;//表示，第几个数字
	 
	for(int j=1;s<13;s++,j++)
	{
		test[s].c='S';
		test[s].num=j;
		test[s].x=s;
	}
	
	for(int j=1;s<26;s++,j++)
	{
		test[s].c='H';
		test[s].num=j;
		test[s].x=s;
	}
	
	for(int j=1;s<39;s++,j++)
	{
		test[s].c='C';
		test[s].num=j;
		test[s].x=s;
	}
	
	for(int j=1;s<52;s++,j++)
	{
		test[s].c='D';
		test[s].num=j;
		test[s].x=s;
	}
	
	for(int j=1;s<54;s++,j++)
	{
		test[s].c='J';
		test[s].num=j;
		test[s].x=s;
	}
	
	
	int n;
	scanf("%d",&n);
	
	for(int i=0;i<54;i++)
	{
		scanf("%d",&kk[i]);
	}
	
	for(int i=0;i<n;i++)
	{
		
		for(int j=0;j<54;j++)
		{
			test[j].x=kk[j];
		}
		sort(test,test+54,cmp);
	}
	
	
	for(int j=0;j<53;j++)
	{
		printf("%c%d ",test[j].c,test[j].num);
	}
	printf("%c%d",test[53].c,test[53].num);
	
	return 0;
 } 
```









## A 1046	Shortest Distance



```cpp
//#include<iostream>
#include<cstdio>

//using namespace std;

//int lowbit(int x)
//{
//	return x&(-x);
//}
//
//int getSum(int x,int c[])
//{
//	int sum_temp=0;
//	for(int i=x;i>0;i-=lowbit(i))
//	{
//		sum_temp+=c[i] ;
//	}
//	
//	return sum_temp;
//}





int main()
{
	int sum=0;
	int n;
	scanf("%d",&n);
	
	int test[n];//存响铃的 
	int bit[n];//he，1表示。。。
	 
	for(int i=1;i<n;i++)
	{
		scanf("%d",&test[i]);
		sum+=test[i];
		bit[i]=sum;
	}
	scanf("%d",&test[0]);
	sum+=test[0];
	
	
	
	
	
	int one;
	scanf("%d",&one);
	
	int out[one];//shuch 
	
	int a,b;
	int num=0;
	for(int i=0;i<one;i++)
	{
		scanf("%d%d",&a,&b);
		
		int temp=a;
		if(a>b)
		{
			a=b;
			b=temp;
		}
		
		if((b-a==1)&&(a==1))
		num=bit[1];
		else if((b-a==1)&&(a!=1))
		num=bit[a]-bit[a-1];
		else if((a==1)&&(b-a)>1)
		num=bit[b-1];
		else
		num=bit[b-1]-bit[a-1];
//		for(int jj=a;jj<b;jj++)
//		{
//			num+=test[jj];
//		}
		
		if(num<(sum-num))
		out[i]=num;
		else
		out[i]=sum-num;
		
		num=0;
	}
	
	
	for(int i=0;i<one-1;i++)
	{
		printf("%d\n",out[i]);
	}
		printf("%d",out[one-1]);
		
		
	
	return 0;
 } 
```





## A 1054The Dominant Color   20



- 水题

- 求超过一半的数字

方法一：使用C++语言特性解，不是面试最优解！当然，可以AC

- 注意：由于是

- ```cpp
  map<int,int> mp;//我没有用mp.find( val_Key )
  //查找mp.find( val_Key )!=mp.end();//这个写法是重点
  ```

- `//注意，C++11的这种for循环，用的是map<int,int> mp中的元素类似。不是迭代器！！！`



```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
	int a,b;
	while( ~scanf("%d%d",&a,&b) )
	{
		map<int,int> mp;
		int temp;
		int loop=a*b;
		while( loop-- )
		{
			scanf("%d",&temp);
			mp[temp]++;
		}	
		
		int num=0x3f3f3f;
		int count=0;
		
        //注意，C++11的这种for循环，用的是map<int,int> mp中的元素类似。不是迭代器！！！
		for( auto it : mp )
		{
			if( (it).second > count )
			{
				num=it.first;
				count=(it).second;
			}
		}
		
		printf("%d\n",num);
		
		
	}
	
	return 0;
}

```

方法2，使用『摩尔投票法』

思路：

由于题目要求必须超过『半数』（我们可以想象，假设，这些数字都隔着放，其他的元素插入到他们中间，总会有半数的那个在某个位置领近，当然11和222和3333这样的，也需要考虑）

有超过半数的数字相同，如果采用两两不相同的数**相互抵消**的做法，最后一定会剩下那个超过半数的数字。



**比LeetCode上更好理解的『摩尔投票法求众数的步骤』**

ans 『存答案（数字）』

count是计数变量，『**计数ans出现的次数**』

输入某元素val的时候进行

判断val和ans
- `val==ans`
   - 则++count
- `val!=ans`
  - （1）`0==count`，则ans=val，count=1  ，翻译为中文很容易理解算法：元素val出现1次
  - （2）`--count`，ans不变，，如果不想等，则令其抵消1次

转换为代码就是

```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
	int a,b;
	while( ~scanf("%d%d",&a,&b) )
	{
		
		int val;
		int loop=a*b;
		
		//翻译为中文很容易理解算法：元素ans出现0次 （哨兵写法）
		int ans=0x3f3f3f;
		int count=0;
		while( loop-- )
		{
			scanf("%d",&val);
			
			if( val==ans )
			{
				++count;
			}
			else
			{
				//核心代码
				if( 0==count )
				{
					ans=val;
					count=1;
				}
				else
				{
					--count;
				}
			}
			
		}	
		
		printf("%d\n",ans);
	}
	
	return 0;
}

```



## A1058 **1058** **A+B in Hogwarts** (20分)

- 水题

```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
	int firstA,firstB,firstC;
	int secondA,secondB,secondC;
	while( ~scanf("%d.%d.%d %d.%d.%d",&firstA, &firstB, &firstC
		, &secondA, &secondB, &secondC) )
	{
		int carry=0;
		int temp=(firstC+secondC)%29;
		carry = (firstC+secondC)/29 ? (firstC+secondC)/29 :0 ;
		firstC=temp;

		temp=(firstB+secondB+carry)%17;
		carry = (firstB+secondB+carry)/17 ? (firstB+secondB+carry)/17 :0 ;
		firstB=temp;


		firstA=firstA+secondA+carry;

		printf("%d.%d.%d\n",firstA,firstB,firstC);
	}


	return 0;
}
```





## A1065	A+B and C (64bit)（很又有的技巧，判断64位的溢出）

技巧：判断long long相加和相减的溢出，技巧

《计算机组成原理》中指出，如何两个正数之和等于负数，或者两个负数之和等于正数，就是溢出。

我们需要考虑，两个整数相加所会导致的正溢出或者负溢出

```cpp
#include<cstdio>

int out[11]={0};

int test(long long a,long long b,long long c)
{
	//1表示true 
	long long t=a+b;
	 
	if((a>0)&&(b>0)&&(t<=0))
	{
		//相加太大的溢出 
		return 1; 
	}
	else if((a<0)&&(b<0)&&(t>=0))
	{
		//两个负数相加的溢出
		return 0; 
	}
	else if(t>c)
	return 1;
	else
	return 0;
	
 } 

int main()
{
	int n;
	scanf("%d",&n);
	
	long long a,b,c;
	
	for(int i=1;i<=n;i++)
	{
		scanf("%lld%lld%lld",&a,&b,&c);
		out[i]=test(a,b,c);
	}
	
	int i=1;
	for(;i<n;i++)
	{
		if(out[i])
		printf("Case #%d: true\n",i);
		else
		printf("Case #%d: false\n",i);
	}
	
	if(out[i])
	printf("Case #%d: true",i);
	else
	printf("Case #%d: false",i);
	
	
	return 0;
 } 
```





## A1083 List Grades (25分)

- 水题

//『算法笔记』上说：经过测试，考生数量不会超过50
//我在写的时候，也考虑过这个。但是题目中没有讲，我只能大概以为是大学一个院系，也就几百，也能这么排序
//反正考点是sort的『规则函数』，我自己随便编的名字

```cpp

#include<bits/stdc++.h>
using namespace std;

struct  node
{
	char name[30];
	char num[30];
	int val;
};

//我随便给他取个名字吧：根据它的功能，我叫他为『规则函数』，因为它就是体现排序规则的函数
bool cmp(node a, node b)
{
	return a.val>b.val;
}

int main()
{
	int n,Left,Right;
	while( ~scanf("%d",&n) )
	{
		vector<node> solve;
		while( n-- )
		{
			node temp;
			scanf("%s %s %d",temp.name, temp.num, &temp.val);
			solve.push_back( temp );
		}
		scanf("%d%d",&Left,&Right);
		sort( solve.begin(), solve.end(), cmp);

		int tag=0;
		for( auto temp: solve )
		{
			if( temp.val >=Left && temp.val<=Right )
			{
				printf("%s %s\n",temp.name, temp.num);
				tag=1;
			}
		}

		if( 0==tag )
		{
			printf("NONE\n");
		}
	}

	return 0;
}
```







