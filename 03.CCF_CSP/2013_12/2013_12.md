# 2013-12

注意，由于CCF不实时显示得分，所以，我们要自行测试**边界数据**
会做的一定要得到100



## 1）出现次数最多的数

考点：hash

```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxn=10000+5; 
int _hash[maxn];

int main()
{
	
	int n;
	while(~scanf("%d",&n))
	{
		memset(_hash,0,sizeof(_hash));
		
		int temp;
		for(int i=0;i<n;++i)
		{
			scanf("%d",&temp); 
			_hash[temp]++;
		}
		
		int _max=-1;
		for(int i=0;i<maxn;++i)
		{
			_max=max(_max,_hash[i]);
		}
	
		for(int i=0;i<maxn;++i)
		{
			if(_max==_hash[i])
			{
				printf("%d\n",i);
				break;
			}
		}
		
	} 
	
	return 0;
}
```







##  2）



## 3）最大的矩形


### 解法1（单调栈）
运行时间：15ms
似乎有2种说法
[CSDN上](https://blog.csdn.net/XxxxxM1/article/details/81324228)
[挑战程序设计竞赛书上]

核心都是将问题转换，然后，发现转换后的问题可以用单调栈来解决。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxn=1000+5;
int height[maxn];

int Left[maxn];
int Right[maxn];


//构造前n个元素的Left和Right数组 
void solution(int n)
{
	stack<int> stack_index;
	
	//Left数组
	for(int i=0;i<n;++i)
	{
		//如果非空，并且栈中元素大于等于左边，可以更新 
		while((!stack_index.empty())&&(height[stack_index.top()]>=height[i]))
		{
			stack_index.pop(); 
		}	
		
//		Left[i]= (stack_index.empty()) ? 0 : stack_index.top()+1;
		if(stack_index.empty())
		{
			//左闭的最左边是0 
			Left[i]=0;
		}
		else
		{
			//因为是左闭区间 
			Left[i]=stack_index.top()+1;
		}
		
		//注意是放入下表index 
		stack_index.push(i);
	} 
	
	
	while(!stack_index.empty())
	{
		stack_index.pop();
	}
	
	//Right数组,注意遍历方向 
	for(int i=n-1;i>=0;--i)
	{
		//如果非空，并且栈中元素大于等于右边，可以更新 
		while((!stack_index.empty())&&(height[stack_index.top()]>=height[i]))
		{
			stack_index.pop(); 
		}	
		
//		Right[i]= (stack_index.empty()) ? n : stack_index.top();
		if(stack_index.empty())
		{
			//右开的最右边是n 
			Right[i]=n;
		}
		else
		{
			//因为是右开区间 
			Right[i]=stack_index.top();
		}
		
		//注意是放入下表index 
		stack_index.push(i);
	} 
	
	
}


int main()
{
	int n;
	while(~scanf("%d",&n))
	{
		memset(Left,0,sizeof(Left));
		memset(Right,0,sizeof(Right));
		
		for(int i=0;i<n;++i)
		{
			scanf("%d",&height[i]); 
		} 
		
		//构造Left和Right数组 
		solution(n);
		
		//防止溢出 
		long long  _max=0;
		for(int i=0;i<n;++i)
		{
			_max=max(_max,(((long long)Right[i]-(long long)Left[i])*(long long)height[i]));
//			printf("Left=%d\n",Left[i]);
//			printf("Right=%d\n",Right[i]);
		}
		
		printf("%lld\n",_max);
	}
	
	
	return 0;
}
```




### 解法2（暴力）
可行性原因：数据量少
提醒我们，做题的时候，可以根据数据量来进行编程。

时间使用640ms

```cpp
#include<bits/stdc++.h>
using namespace std;


const int maxn=1000+5; 
int height[maxn];


//返回区间[left,right]中最矮的 
int rt(int left,int right)
{
	int num=0x3f3f3f3f;
	while(left<=right)
	{
		num=min(num,height[left]);
		++left;
	}
	
	return num;
} 



int main()
{
	
	int n;
	while(~scanf("%d",&n))
	{
		
		for(int i=0;i<n;++i)
		{
			scanf("%d",&height[i]);
		}
		
		int _max=-1;
		for(int i=0;i<n;++i)
		{
			for(int len=1;i+len<=n;++len)
			{
				_max=max(_max,len*rt(i,i+len-1));
			}
		}
		
		
		printf("%d\n",_max);
		
	} 
	
	return 0;
}
```














