

## 1.位对齐



### （1）1.第一次提交（91.67对位运算和（进位）加减有偏差）

```cpp
#include<stdio.h>
unsigned int align_n(unsigned int size, int n)
{
	
	
	unsigned int test=(1<<n)-1;//第0-n位全是1 
	
	unsigned int temp=size;//复制 
	temp&=(~(test<<(32-n))); //获得第0-n位的位

	
	unsigned int out;
	
	if(temp&test)//如果有1 
	{

		size&=(~test);
		
//		printf("size=%d\n",size);
		out=size^(1<<n);
//		printf("OK");
		
		return out;
	}
	
	
	
	out=size&=(~test);;
	return out;
	
}

int main()
{
	unsigned int size,out;
	int n;
	scanf("0x%x,%d",&size,&n);
//	printf("size=%x,n=%d\n",size,n); 
	out=align_n(size,n);
	
	printf("0x%x",out); 
	return 0; 
} 

```

![91.67](./\91.67.png)

### (2)2.第二次AC

```cpp
#include<stdio.h>
unsigned int align_n(unsigned int size, int n)
{
	
	
	unsigned int test=(1<<n)-1;//第0-n位全是1 
	
	unsigned int temp=size;//复制 
	temp&=(~(test<<(32-n))); //获得第0-n位的位

	
	unsigned int out;
	
	if(temp&test)//如果有1 
	{

		size&=(~test);//末尾置0 
		
//		printf("size=%d\n",size);
		if(size&(1<<n)) 
		{
//			printf("OK");//错在这里 
			
			out=size+(1<<n);
		}
		else
		{
			out=size^(1<<n);//错在这里 ,如果那个地方是0可以，要是1要进位 
		}
		
//		printf("OK");
		
		return out;
	}
	
	
	
	out=size&=(~test);;
	return out;
	
}

int main()
{
	unsigned int size,out;
	int n;
	scanf("0x%x,%d",&size,&n);
//	printf("size=%x,n=%d\n",size,n); 
	out=align_n(size,n);
	
	printf("0x%x",out); 
	return 0; 
} 

```



## 2.堆排序（代码填空题）—未解决

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
static void heap_arrange(int arr[], int cur, int cnt);

static int heap_verify(int arr[], int cnt)
{
    int i;
    for (i = 0; i < cnt / 2; ++i) {
        int lhs = 2 * i + 1;
        int rhs = 2 * i + 2;
        
        if (lhs < cnt && arr[i] > arr[lhs]) {
            fprintf(stderr, "arr[%d]:%d > arr[%d]:%d\n", i, arr[i], lhs, arr[lhs]);
            return -1;
        }
        if (rhs < cnt && arr[i] > arr[rhs]) {
            fprintf(stderr, "arr[%d]:%d > arr[%d]:%d\n", i, arr[i], rhs, arr[rhs]);
            return -1;
        }
    }
    return 0;
}

static void heap_print(int arr[], int cnt)
{
    int layer = 0, num = 0;
    for (layer = 0; num < cnt; ++layer) {
        int i = 0;
        for (i = 0 ; i < (1 << layer) && num < cnt ; ++i)
            printf("%3d ", arr[num++]);
        printf("\n");
    }
}
static void heap_sort(int arr[], int cnt)
{
    int i;

    printf("origin:\n");
    heap_print(arr, cnt);
    //  建堆
    for (i = cnt / 2 - 1; i >= 0; --i) {
        heap_arrange(arr, i, cnt);
    }
    printf("make heap:\n", i);
    heap_print(arr, cnt);
    assert(heap_verify(arr, cnt) == 0);
    for (i = cnt - 1; i > 0; --i) {
        int tmp;
        tmp = arr[0];
        arr[0] = arr[i];
        arr[i] = tmp;
        printf("sort i=%d\n", i);
        heap_print(arr, cnt);
        heap_arrange(arr, 0, i);
        heap_print(arr, cnt);
        assert(heap_verify(arr, i) == 0);
    }
    printf("sorted:\n");
    heap_print(arr, cnt);
}
static int input(int **arr, int *size)
{
    int i;
    int ret;

    ret = fscanf(stdin, "%d\n", size);
    if (ret != 1)
        return -1;
    *arr = (int *)malloc(sizeof(int) * (*size));
    for (i = 0; i < *size; ++i) {
        fscanf(stdin, "%d ", &(*arr)[i]);
    }
    return 0;
}

int main(int argc, char *argv[])
{
    int *arr = NULL;
    int cnt = 0;
    int i;

    if (input(&arr, &cnt) < 0) {
        fprintf(stderr, "input error\n");
        return 0;
    }
    heap_sort(arr, cnt);
    return 0;
}
//  调整为小顶堆
static void heap_arrange(int arr[], int cur, int cnt)  //调整为小顶堆
{
    int heaptop_val = arr[cur]; //堆顶的值
    while (cur < cnt) {
        int left = 2 * cur + 1;
        int right = 2 * cur + 2;
        int min = -1;
        int min_val = heaptop_val;
        if (left < cnt && arr[left] < min_val) { //检查是否比左节点大
            min = left;
            min_val = arr[left];
        }
        if (right < cnt && arr[right] < min_val) {//检查是否比右节点大
            min = right;
        }
        if (min == -1)
            break;
        arr[cur] = arr[min];
        cur = min;
    }
    arr[cur] = heaptop_val;
}

```



## 3.最优二叉树（填空题）—未解决

```cpp
#include <stdio.h>
#include <limits.h>
#include <assert.h>
#include <malloc.h>

struct node {
    int left, right, parent;
    int val;
};

void tree_print(const struct node arr[], int cnt)
{
    int i;
    for (i = 0; i < cnt; ++i) {
        fprintf(stderr, "%d: {left:%d,right:%d,parent:%d,val:%d}\n"
            , i, arr[i].left, arr[i].right, arr[i].parent, arr[i].val);
    }
}

void tree_output(FILE *fp, const struct node arr[], int old_cnt, int cnt)
{
    int i;
    fprintf(fp, "```mermaid\n");
    fprintf(fp, "graph TD\n");
    for (i = 0; i < cnt; ++i) {
        if (i < old_cnt)
            fprintf(fp, "\tn%d[n%d:%d]\n", i, i, arr[i].val);
        else
            fprintf(fp, "\tn%d((%d))\n", i, arr[i].val);

        if (arr[i].parent >= 0) {
            fprintf(fp, "\tn%d --> n%d\n", i, arr[i].parent);
        }
    }
    fprintf(fp, "```\n");
}

int build_tree(struct node arr[], int cnt);

static int input(int **arr, int *size)
{
    int i;
    int ret;

    ret = fscanf(stdin, "%d\n", size);
    if (ret != 1)
        return -1;
    if (*size <= 0)
        return -1;
    *arr = (int *)malloc(sizeof(int) * (*size));
    for (i = 0; i < *size; ++i) {
        fscanf(stdin, "%d ", &(*arr)[i]);
    }
    return 0;
}
int main(int argc, char *argv[])
{
    int *vals = NULL;
    int cnt = 0;
    struct node *arr;
    int i;

    if (input(&vals, &cnt) < 0) {
        fprintf(stderr, "input error\n");
        return 0;
    }
    arr = (struct node *)malloc(sizeof(struct node) * cnt * 3);

    for (i = 0; i < cnt; ++i) {
        arr[i].left = -1;
        arr[i].right = -1;
        arr[i].parent = -1;
        arr[i].val = vals[i];
    }

    int newcnt = build_tree(arr, cnt);
    tree_output(stdout, arr, cnt, newcnt);
    free(vals);
    free(arr);
    return 0;
}

//  建树，返回树的根节点
int build_tree(struct node arr[], int cnt)
{
    while (1) {
        int i;
        int min1 = -1;              //权值最小的节点编号
        int min2 = -1;              //权值第二小的节点编号
        int root_node = 0;          //根节点(没有父节点)的个数

        for (i = 0; i < cnt; ++i) {
            if (arr[i].parent>= 0)    //拥有父节点,则跳过这个结点
                continue;
            ++root_node;        //根节点加1
            if (min1 < 0) {
                min1 = i;
            } else if (arr[i].val < arr[min1].val) {    //出现比第一更小的,更新
                min2 = min1;
                min1 = i;
            } else if (min2 < 0) {
                min2 = i;
            } else if (arr[i].val < arr[min2].val) {    //当前节点权值比第二小节点更小
                min2 = i;
            }
        }
        if (root_node < 2)
            break;
        arr[cnt].left = min2;
        arr[cnt].right = min1;
        arr[cnt].val = arr[min1].val + arr[min2].val;
        arr[cnt].parent = -1;
        arr[min1].parent = cnt;
        arr[min2].parent = cnt;
        ++cnt;
    }
    return cnt;
}

```

